// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: das.proto

#ifndef PROTOBUF_das_2eproto__INCLUDED
#define PROTOBUF_das_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace das {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_das_2eproto();
void protobuf_AssignDesc_das_2eproto();
void protobuf_ShutdownFile_das_2eproto();

class PostHeartBeat;
class AckHeartBeat;
class ParameterDescription;
class QueryParameters;
class AckQueryParameters;
class ConfigureParameters;
class AckConfigurParameters;
class UpdateDeviceList;
class AckUpdateDeviceList;
class RequestIdentityAllocation;
class AckIdentityAllocation;
class PostProgram;
class AckPostProgram;
class NotifyProgram;
class AckNotifyProgram;
class RequestProgram;
class AckRequestProgram;
class RequestPositionAuthentication;
class AckPositionAuthentication;
class Request3rdIdentityAuthentication;
class Ack3rdIdentityAuthentication;
class RequestUavIdentityAuthentication;
class AckUavIdentityAuthentication;
class RequestNewGS;
class AckNewGS;
class RequestGSIdentityAuthentication;
class AckGSIdentityAuthentication;
class GpsInformation;
class UavAttitude;
class OperationStatus;
class OperationParams;
class OperationInformation;
class PostOperationInformation;
class AckOperationInformation;
class Coordinate;
class OperationSnapshot;
class PostOperationSnapshot;
class AckPostOperationSnapshot;
class Outline;
class ParcelSurveyInformation;
class PostParcelSurveyInformation;
class AckPostParcelSurveyInformation;
class RequestParcelSurveyInformations;
class AckRequestParcelSurveyInformations;
class ParcelContracter;
class ParcelDescription;
class PostParcelDescription;
class AckPostParcelDescription;
class RequestParcelDescriptions;
class AckRequestParcelDescriptions;
class DeleteParcelDescription;
class AckDeleteParcelDescription;
class SingleShrink;
class OperationPlan;
class OperationDescription;
class PostOperationDescription;
class AckPostOperationDescription;
class RequestOperationDescriptions;
class AckRequestOperationDescriptions;
class DeleteOperationDescription;
class AckDeleteOperationDescription;
class BillInformation;
class OperationRoute;
class PostOperationRoute;
class AckPostOperationRoute;
class UploadOperationRoutes;
class SyscOperationRoutes;
class RequestRouteMissions;
class AckRequestRouteMissions;
class UavStatus;
class RequestUavStatus;
class AckRequestUavStatus;
class RequestBindUav;
class AckRequestBindUav;
class UavProductInfo;
class RequestUavProductInfos;
class AckRequestUavProductInfos;
class PostUavProductInfos;
class AckPostUavProductInfos;
class PostControl2Uav;
class AckPostControl2Uav;
class PostStatus2GroundStation;

enum SurveryPrecision {
  LOW = 1,
  MEDIUM = 2,
  HIGH = 3
};
bool SurveryPrecision_IsValid(int value);
const SurveryPrecision SurveryPrecision_MIN = LOW;
const SurveryPrecision SurveryPrecision_MAX = HIGH;
const int SurveryPrecision_ARRAYSIZE = SurveryPrecision_MAX + 1;

const ::google::protobuf::EnumDescriptor* SurveryPrecision_descriptor();
inline const ::std::string& SurveryPrecision_Name(SurveryPrecision value) {
  return ::google::protobuf::internal::NameOfEnum(
    SurveryPrecision_descriptor(), value);
}
inline bool SurveryPrecision_Parse(
    const ::std::string& name, SurveryPrecision* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SurveryPrecision>(
    SurveryPrecision_descriptor(), name, value);
}
// ===================================================================

class PostHeartBeat : public ::google::protobuf::Message {
 public:
  PostHeartBeat();
  virtual ~PostHeartBeat();

  PostHeartBeat(const PostHeartBeat& from);

  inline PostHeartBeat& operator=(const PostHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostHeartBeat& default_instance();

  void Swap(PostHeartBeat* other);

  // implements Message ----------------------------------------------

  PostHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostHeartBeat& from);
  void MergeFrom(const PostHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:das.proto.PostHeartBeat)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class AckHeartBeat : public ::google::protobuf::Message {
 public:
  AckHeartBeat();
  virtual ~AckHeartBeat();

  AckHeartBeat(const AckHeartBeat& from);

  inline AckHeartBeat& operator=(const AckHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHeartBeat& default_instance();

  void Swap(AckHeartBeat* other);

  // implements Message ----------------------------------------------

  AckHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckHeartBeat& from);
  void MergeFrom(const AckHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckHeartBeat)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class ParameterDescription : public ::google::protobuf::Message {
 public:
  ParameterDescription();
  virtual ~ParameterDescription();

  ParameterDescription(const ParameterDescription& from);

  inline ParameterDescription& operator=(const ParameterDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParameterDescription& default_instance();

  void Swap(ParameterDescription* other);

  // implements Message ----------------------------------------------

  ParameterDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParameterDescription& from);
  void MergeFrom(const ParameterDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bool readonly = 2;
  inline bool has_readonly() const;
  inline void clear_readonly();
  static const int kReadonlyFieldNumber = 2;
  inline bool readonly() const;
  inline void set_readonly(bool value);

  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required string value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:das.proto.ParameterDescription)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_readonly();
  inline void clear_has_readonly();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  bool readonly_;
  ::google::protobuf::uint32 type_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static ParameterDescription* default_instance_;
};
// -------------------------------------------------------------------

class QueryParameters : public ::google::protobuf::Message {
 public:
  QueryParameters();
  virtual ~QueryParameters();

  QueryParameters(const QueryParameters& from);

  inline QueryParameters& operator=(const QueryParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryParameters& default_instance();

  void Swap(QueryParameters* other);

  // implements Message ----------------------------------------------

  QueryParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryParameters& from);
  void MergeFrom(const QueryParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated string pdnames = 3;
  inline int pdnames_size() const;
  inline void clear_pdnames();
  static const int kPdnamesFieldNumber = 3;
  inline const ::std::string& pdnames(int index) const;
  inline ::std::string* mutable_pdnames(int index);
  inline void set_pdnames(int index, const ::std::string& value);
  inline void set_pdnames(int index, const char* value);
  inline void set_pdnames(int index, const char* value, size_t size);
  inline ::std::string* add_pdnames();
  inline void add_pdnames(const ::std::string& value);
  inline void add_pdnames(const char* value);
  inline void add_pdnames(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pdnames() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pdnames();

  // @@protoc_insertion_point(class_scope:das.proto.QueryParameters)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pdnames_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static QueryParameters* default_instance_;
};
// -------------------------------------------------------------------

class AckQueryParameters : public ::google::protobuf::Message {
 public:
  AckQueryParameters();
  virtual ~AckQueryParameters();

  AckQueryParameters(const AckQueryParameters& from);

  inline AckQueryParameters& operator=(const AckQueryParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckQueryParameters& default_instance();

  void Swap(AckQueryParameters* other);

  // implements Message ----------------------------------------------

  AckQueryParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckQueryParameters& from);
  void MergeFrom(const AckQueryParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .das.proto.ParameterDescription pd = 4;
  inline int pd_size() const;
  inline void clear_pd();
  static const int kPdFieldNumber = 4;
  inline const ::das::proto::ParameterDescription& pd(int index) const;
  inline ::das::proto::ParameterDescription* mutable_pd(int index);
  inline ::das::proto::ParameterDescription* add_pd();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >&
      pd() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >*
      mutable_pd();

  // @@protoc_insertion_point(class_scope:das.proto.AckQueryParameters)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription > pd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckQueryParameters* default_instance_;
};
// -------------------------------------------------------------------

class ConfigureParameters : public ::google::protobuf::Message {
 public:
  ConfigureParameters();
  virtual ~ConfigureParameters();

  ConfigureParameters(const ConfigureParameters& from);

  inline ConfigureParameters& operator=(const ConfigureParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigureParameters& default_instance();

  void Swap(ConfigureParameters* other);

  // implements Message ----------------------------------------------

  ConfigureParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigureParameters& from);
  void MergeFrom(const ConfigureParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated .das.proto.ParameterDescription pd = 3;
  inline int pd_size() const;
  inline void clear_pd();
  static const int kPdFieldNumber = 3;
  inline const ::das::proto::ParameterDescription& pd(int index) const;
  inline ::das::proto::ParameterDescription* mutable_pd(int index);
  inline ::das::proto::ParameterDescription* add_pd();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >&
      pd() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >*
      mutable_pd();

  // @@protoc_insertion_point(class_scope:das.proto.ConfigureParameters)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription > pd_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static ConfigureParameters* default_instance_;
};
// -------------------------------------------------------------------

class AckConfigurParameters : public ::google::protobuf::Message {
 public:
  AckConfigurParameters();
  virtual ~AckConfigurParameters();

  AckConfigurParameters(const AckConfigurParameters& from);

  inline AckConfigurParameters& operator=(const AckConfigurParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckConfigurParameters& default_instance();

  void Swap(AckConfigurParameters* other);

  // implements Message ----------------------------------------------

  AckConfigurParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckConfigurParameters& from);
  void MergeFrom(const AckConfigurParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckConfigurParameters)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckConfigurParameters* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDeviceList : public ::google::protobuf::Message {
 public:
  UpdateDeviceList();
  virtual ~UpdateDeviceList();

  UpdateDeviceList(const UpdateDeviceList& from);

  inline UpdateDeviceList& operator=(const UpdateDeviceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDeviceList& default_instance();

  void Swap(UpdateDeviceList* other);

  // implements Message ----------------------------------------------

  UpdateDeviceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDeviceList& from);
  void MergeFrom(const UpdateDeviceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required uint32 operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::google::protobuf::uint32 operation() const;
  inline void set_operation(::google::protobuf::uint32 value);

  // repeated string id = 3;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id(int index) const;
  inline ::std::string* mutable_id(int index);
  inline void set_id(int index, const ::std::string& value);
  inline void set_id(int index, const char* value);
  inline void set_id(int index, const char* value, size_t size);
  inline ::std::string* add_id();
  inline void add_id(const ::std::string& value);
  inline void add_id(const char* value);
  inline void add_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_id();

  // @@protoc_insertion_point(class_scope:das.proto.UpdateDeviceList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_operation();
  inline void clear_has_operation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 operation_;
  ::google::protobuf::RepeatedPtrField< ::std::string> id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static UpdateDeviceList* default_instance_;
};
// -------------------------------------------------------------------

class AckUpdateDeviceList : public ::google::protobuf::Message {
 public:
  AckUpdateDeviceList();
  virtual ~AckUpdateDeviceList();

  AckUpdateDeviceList(const AckUpdateDeviceList& from);

  inline AckUpdateDeviceList& operator=(const AckUpdateDeviceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpdateDeviceList& default_instance();

  void Swap(AckUpdateDeviceList* other);

  // implements Message ----------------------------------------------

  AckUpdateDeviceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpdateDeviceList& from);
  void MergeFrom(const AckUpdateDeviceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckUpdateDeviceList)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckUpdateDeviceList* default_instance_;
};
// -------------------------------------------------------------------

class RequestIdentityAllocation : public ::google::protobuf::Message {
 public:
  RequestIdentityAllocation();
  virtual ~RequestIdentityAllocation();

  RequestIdentityAllocation(const RequestIdentityAllocation& from);

  inline RequestIdentityAllocation& operator=(const RequestIdentityAllocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestIdentityAllocation& default_instance();

  void Swap(RequestIdentityAllocation* other);

  // implements Message ----------------------------------------------

  RequestIdentityAllocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestIdentityAllocation& from);
  void MergeFrom(const RequestIdentityAllocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string devtype = 2;
  inline bool has_devtype() const;
  inline void clear_devtype();
  static const int kDevtypeFieldNumber = 2;
  inline const ::std::string& devtype() const;
  inline void set_devtype(const ::std::string& value);
  inline void set_devtype(const char* value);
  inline void set_devtype(const char* value, size_t size);
  inline ::std::string* mutable_devtype();
  inline ::std::string* release_devtype();
  inline void set_allocated_devtype(::std::string* devtype);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.RequestIdentityAllocation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_devtype();
  inline void clear_has_devtype();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* devtype_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestIdentityAllocation* default_instance_;
};
// -------------------------------------------------------------------

class AckIdentityAllocation : public ::google::protobuf::Message {
 public:
  AckIdentityAllocation();
  virtual ~AckIdentityAllocation();

  AckIdentityAllocation(const AckIdentityAllocation& from);

  inline AckIdentityAllocation& operator=(const AckIdentityAllocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckIdentityAllocation& default_instance();

  void Swap(AckIdentityAllocation* other);

  // implements Message ----------------------------------------------

  AckIdentityAllocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckIdentityAllocation& from);
  void MergeFrom(const AckIdentityAllocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string extradata = 4;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 4;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.AckIdentityAllocation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* id_;
  ::std::string* extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckIdentityAllocation* default_instance_;
};
// -------------------------------------------------------------------

class PostProgram : public ::google::protobuf::Message {
 public:
  PostProgram();
  virtual ~PostProgram();

  PostProgram(const PostProgram& from);

  inline PostProgram& operator=(const PostProgram& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostProgram& default_instance();

  void Swap(PostProgram* other);

  // implements Message ----------------------------------------------

  PostProgram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostProgram& from);
  void MergeFrom(const PostProgram& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional int32 fwtype = 5;
  inline bool has_fwtype() const;
  inline void clear_fwtype();
  static const int kFwtypeFieldNumber = 5;
  inline ::google::protobuf::int32 fwtype() const;
  inline void set_fwtype(::google::protobuf::int32 value);

  // optional int32 length = 6;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 6;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional uint32 crc32 = 7;
  inline bool has_crc32() const;
  inline void clear_crc32();
  static const int kCrc32FieldNumber = 7;
  inline ::google::protobuf::uint32 crc32() const;
  inline void set_crc32(::google::protobuf::uint32 value);

  // optional bool release = 8;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 8;
  inline bool release() const;
  inline void set_release(bool value);

  // @@protoc_insertion_point(class_scope:das.proto.PostProgram)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_fwtype();
  inline void clear_has_fwtype();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_crc32();
  inline void clear_has_crc32();
  inline void set_has_release();
  inline void clear_has_release();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 offset_;
  ::std::string* data_;
  ::google::protobuf::int32 fwtype_;
  ::google::protobuf::int32 length_;
  ::google::protobuf::uint32 crc32_;
  bool release_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostProgram* default_instance_;
};
// -------------------------------------------------------------------

class AckPostProgram : public ::google::protobuf::Message {
 public:
  AckPostProgram();
  virtual ~AckPostProgram();

  AckPostProgram(const AckPostProgram& from);

  inline AckPostProgram& operator=(const AckPostProgram& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostProgram& default_instance();

  void Swap(AckPostProgram* other);

  // implements Message ----------------------------------------------

  AckPostProgram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostProgram& from);
  void MergeFrom(const AckPostProgram& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostProgram)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostProgram* default_instance_;
};
// -------------------------------------------------------------------

class NotifyProgram : public ::google::protobuf::Message {
 public:
  NotifyProgram();
  virtual ~NotifyProgram();

  NotifyProgram(const NotifyProgram& from);

  inline NotifyProgram& operator=(const NotifyProgram& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyProgram& default_instance();

  void Swap(NotifyProgram* other);

  // implements Message ----------------------------------------------

  NotifyProgram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyProgram& from);
  void MergeFrom(const NotifyProgram& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 fwtype = 4;
  inline bool has_fwtype() const;
  inline void clear_fwtype();
  static const int kFwtypeFieldNumber = 4;
  inline ::google::protobuf::int32 fwtype() const;
  inline void set_fwtype(::google::protobuf::int32 value);

  // required int32 length = 5;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 5;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // required uint32 crc32 = 6;
  inline bool has_crc32() const;
  inline void clear_crc32();
  static const int kCrc32FieldNumber = 6;
  inline ::google::protobuf::uint32 crc32() const;
  inline void set_crc32(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:das.proto.NotifyProgram)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fwtype();
  inline void clear_has_fwtype();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_crc32();
  inline void clear_has_crc32();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 fwtype_;
  ::std::string* name_;
  ::google::protobuf::int32 length_;
  ::google::protobuf::uint32 crc32_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static NotifyProgram* default_instance_;
};
// -------------------------------------------------------------------

class AckNotifyProgram : public ::google::protobuf::Message {
 public:
  AckNotifyProgram();
  virtual ~AckNotifyProgram();

  AckNotifyProgram(const AckNotifyProgram& from);

  inline AckNotifyProgram& operator=(const AckNotifyProgram& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckNotifyProgram& default_instance();

  void Swap(AckNotifyProgram* other);

  // implements Message ----------------------------------------------

  AckNotifyProgram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckNotifyProgram& from);
  void MergeFrom(const AckNotifyProgram& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckNotifyProgram)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckNotifyProgram* default_instance_;
};
// -------------------------------------------------------------------

class RequestProgram : public ::google::protobuf::Message {
 public:
  RequestProgram();
  virtual ~RequestProgram();

  RequestProgram(const RequestProgram& from);

  inline RequestProgram& operator=(const RequestProgram& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestProgram& default_instance();

  void Swap(RequestProgram* other);

  // implements Message ----------------------------------------------

  RequestProgram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestProgram& from);
  void MergeFrom(const RequestProgram& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // required int32 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.RequestProgram)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestProgram* default_instance_;
};
// -------------------------------------------------------------------

class AckRequestProgram : public ::google::protobuf::Message {
 public:
  AckRequestProgram();
  virtual ~AckRequestProgram();

  AckRequestProgram(const AckRequestProgram& from);

  inline AckRequestProgram& operator=(const AckRequestProgram& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRequestProgram& default_instance();

  void Swap(AckRequestProgram* other);

  // implements Message ----------------------------------------------

  AckRequestProgram* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRequestProgram& from);
  void MergeFrom(const AckRequestProgram& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 offset = 4;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // optional bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:das.proto.AckRequestProgram)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* name_;
  ::std::string* data_;
  ::google::protobuf::int32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckRequestProgram* default_instance_;
};
// -------------------------------------------------------------------

class RequestPositionAuthentication : public ::google::protobuf::Message {
 public:
  RequestPositionAuthentication();
  virtual ~RequestPositionAuthentication();

  RequestPositionAuthentication(const RequestPositionAuthentication& from);

  inline RequestPositionAuthentication& operator=(const RequestPositionAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPositionAuthentication& default_instance();

  void Swap(RequestPositionAuthentication* other);

  // implements Message ----------------------------------------------

  RequestPositionAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPositionAuthentication& from);
  void MergeFrom(const RequestPositionAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string devid = 2;
  inline bool has_devid() const;
  inline void clear_devid();
  static const int kDevidFieldNumber = 2;
  inline const ::std::string& devid() const;
  inline void set_devid(const ::std::string& value);
  inline void set_devid(const char* value);
  inline void set_devid(const char* value, size_t size);
  inline ::std::string* mutable_devid();
  inline ::std::string* release_devid();
  inline void set_allocated_devid(::std::string* devid);

  // required .das.proto.GpsInformation pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline const ::das::proto::GpsInformation& pos() const;
  inline ::das::proto::GpsInformation* mutable_pos();
  inline ::das::proto::GpsInformation* release_pos();
  inline void set_allocated_pos(::das::proto::GpsInformation* pos);

  // @@protoc_insertion_point(class_scope:das.proto.RequestPositionAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_devid();
  inline void clear_has_devid();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* devid_;
  ::das::proto::GpsInformation* pos_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestPositionAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class AckPositionAuthentication : public ::google::protobuf::Message {
 public:
  AckPositionAuthentication();
  virtual ~AckPositionAuthentication();

  AckPositionAuthentication(const AckPositionAuthentication& from);

  inline AckPositionAuthentication& operator=(const AckPositionAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPositionAuthentication& default_instance();

  void Swap(AckPositionAuthentication* other);

  // implements Message ----------------------------------------------

  AckPositionAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPositionAuthentication& from);
  void MergeFrom(const AckPositionAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string devid = 3;
  inline bool has_devid() const;
  inline void clear_devid();
  static const int kDevidFieldNumber = 3;
  inline const ::std::string& devid() const;
  inline void set_devid(const ::std::string& value);
  inline void set_devid(const char* value);
  inline void set_devid(const char* value, size_t size);
  inline ::std::string* mutable_devid();
  inline ::std::string* release_devid();
  inline void set_allocated_devid(::std::string* devid);

  // @@protoc_insertion_point(class_scope:das.proto.AckPositionAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_devid();
  inline void clear_has_devid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* devid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPositionAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class Request3rdIdentityAuthentication : public ::google::protobuf::Message {
 public:
  Request3rdIdentityAuthentication();
  virtual ~Request3rdIdentityAuthentication();

  Request3rdIdentityAuthentication(const Request3rdIdentityAuthentication& from);

  inline Request3rdIdentityAuthentication& operator=(const Request3rdIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request3rdIdentityAuthentication& default_instance();

  void Swap(Request3rdIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  Request3rdIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request3rdIdentityAuthentication& from);
  void MergeFrom(const Request3rdIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string identification = 2;
  inline bool has_identification() const;
  inline void clear_identification();
  static const int kIdentificationFieldNumber = 2;
  inline const ::std::string& identification() const;
  inline void set_identification(const ::std::string& value);
  inline void set_identification(const char* value);
  inline void set_identification(const char* value, size_t size);
  inline ::std::string* mutable_identification();
  inline ::std::string* release_identification();
  inline void set_allocated_identification(::std::string* identification);

  // required string secretkey = 3;
  inline bool has_secretkey() const;
  inline void clear_secretkey();
  static const int kSecretkeyFieldNumber = 3;
  inline const ::std::string& secretkey() const;
  inline void set_secretkey(const ::std::string& value);
  inline void set_secretkey(const char* value);
  inline void set_secretkey(const char* value, size_t size);
  inline ::std::string* mutable_secretkey();
  inline ::std::string* release_secretkey();
  inline void set_allocated_secretkey(::std::string* secretkey);

  // optional string extradata = 4;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 4;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.Request3rdIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_identification();
  inline void clear_has_identification();
  inline void set_has_secretkey();
  inline void clear_has_secretkey();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* identification_;
  ::std::string* secretkey_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static Request3rdIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class Ack3rdIdentityAuthentication : public ::google::protobuf::Message {
 public:
  Ack3rdIdentityAuthentication();
  virtual ~Ack3rdIdentityAuthentication();

  Ack3rdIdentityAuthentication(const Ack3rdIdentityAuthentication& from);

  inline Ack3rdIdentityAuthentication& operator=(const Ack3rdIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ack3rdIdentityAuthentication& default_instance();

  void Swap(Ack3rdIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  Ack3rdIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ack3rdIdentityAuthentication& from);
  void MergeFrom(const Ack3rdIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.Ack3rdIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static Ack3rdIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class RequestUavIdentityAuthentication : public ::google::protobuf::Message {
 public:
  RequestUavIdentityAuthentication();
  virtual ~RequestUavIdentityAuthentication();

  RequestUavIdentityAuthentication(const RequestUavIdentityAuthentication& from);

  inline RequestUavIdentityAuthentication& operator=(const RequestUavIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUavIdentityAuthentication& default_instance();

  void Swap(RequestUavIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  RequestUavIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUavIdentityAuthentication& from);
  void MergeFrom(const RequestUavIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // optional string extradata = 3;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 3;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.RequestUavIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestUavIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class AckUavIdentityAuthentication : public ::google::protobuf::Message {
 public:
  AckUavIdentityAuthentication();
  virtual ~AckUavIdentityAuthentication();

  AckUavIdentityAuthentication(const AckUavIdentityAuthentication& from);

  inline AckUavIdentityAuthentication& operator=(const AckUavIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUavIdentityAuthentication& default_instance();

  void Swap(AckUavIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  AckUavIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUavIdentityAuthentication& from);
  void MergeFrom(const AckUavIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional uint64 deadline = 4;
  inline bool has_deadline() const;
  inline void clear_deadline();
  static const int kDeadlineFieldNumber = 4;
  inline ::google::protobuf::uint64 deadline() const;
  inline void set_deadline(::google::protobuf::uint64 value);

  // optional string extradata = 5;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtradataFieldNumber = 5;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // @@protoc_insertion_point(class_scope:das.proto.AckUavIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_deadline();
  inline void clear_has_deadline();
  inline void set_has_extradata();
  inline void clear_has_extradata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::uint64 deadline_;
  ::std::string* extradata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckUavIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class RequestNewGS : public ::google::protobuf::Message {
 public:
  RequestNewGS();
  virtual ~RequestNewGS();

  RequestNewGS(const RequestNewGS& from);

  inline RequestNewGS& operator=(const RequestNewGS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestNewGS& default_instance();

  void Swap(RequestNewGS* other);

  // implements Message ----------------------------------------------

  RequestNewGS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestNewGS& from);
  void MergeFrom(const RequestNewGS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string phone = 3;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 3;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string check = 4;
  inline bool has_check() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 4;
  inline const ::std::string& check() const;
  inline void set_check(const ::std::string& value);
  inline void set_check(const char* value);
  inline void set_check(const char* value, size_t size);
  inline ::std::string* mutable_check();
  inline ::std::string* release_check();
  inline void set_allocated_check(::std::string* check);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:das.proto.RequestNewGS)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_check();
  inline void clear_has_check();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* phone_;
  ::std::string* check_;
  ::std::string* password_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestNewGS* default_instance_;
};
// -------------------------------------------------------------------

class AckNewGS : public ::google::protobuf::Message {
 public:
  AckNewGS();
  virtual ~AckNewGS();

  AckNewGS(const AckNewGS& from);

  inline AckNewGS& operator=(const AckNewGS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckNewGS& default_instance();

  void Swap(AckNewGS* other);

  // implements Message ----------------------------------------------

  AckNewGS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckNewGS& from);
  void MergeFrom(const AckNewGS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string check = 3;
  inline bool has_check() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 3;
  inline const ::std::string& check() const;
  inline void set_check(const ::std::string& value);
  inline void set_check(const char* value);
  inline void set_check(const char* value, size_t size);
  inline ::std::string* mutable_check();
  inline ::std::string* release_check();
  inline void set_allocated_check(::std::string* check);

  // @@protoc_insertion_point(class_scope:das.proto.AckNewGS)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_check();
  inline void clear_has_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckNewGS* default_instance_;
};
// -------------------------------------------------------------------

class RequestGSIdentityAuthentication : public ::google::protobuf::Message {
 public:
  RequestGSIdentityAuthentication();
  virtual ~RequestGSIdentityAuthentication();

  RequestGSIdentityAuthentication(const RequestGSIdentityAuthentication& from);

  inline RequestGSIdentityAuthentication& operator=(const RequestGSIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGSIdentityAuthentication& default_instance();

  void Swap(RequestGSIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  RequestGSIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestGSIdentityAuthentication& from);
  void MergeFrom(const RequestGSIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string phone = 4;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 4;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string check = 5;
  inline bool has_check() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 5;
  inline const ::std::string& check() const;
  inline void set_check(const ::std::string& value);
  inline void set_check(const char* value);
  inline void set_check(const char* value, size_t size);
  inline ::std::string* mutable_check();
  inline ::std::string* release_check();
  inline void set_allocated_check(::std::string* check);

  // @@protoc_insertion_point(class_scope:das.proto.RequestGSIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_check();
  inline void clear_has_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* password_;
  ::std::string* phone_;
  ::std::string* check_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestGSIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class AckGSIdentityAuthentication : public ::google::protobuf::Message {
 public:
  AckGSIdentityAuthentication();
  virtual ~AckGSIdentityAuthentication();

  AckGSIdentityAuthentication(const AckGSIdentityAuthentication& from);

  inline AckGSIdentityAuthentication& operator=(const AckGSIdentityAuthentication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGSIdentityAuthentication& default_instance();

  void Swap(AckGSIdentityAuthentication* other);

  // implements Message ----------------------------------------------

  AckGSIdentityAuthentication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGSIdentityAuthentication& from);
  void MergeFrom(const AckGSIdentityAuthentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:das.proto.AckGSIdentityAuthentication)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckGSIdentityAuthentication* default_instance_;
};
// -------------------------------------------------------------------

class GpsInformation : public ::google::protobuf::Message {
 public:
  GpsInformation();
  virtual ~GpsInformation();

  GpsInformation(const GpsInformation& from);

  inline GpsInformation& operator=(const GpsInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GpsInformation& default_instance();

  void Swap(GpsInformation* other);

  // implements Message ----------------------------------------------

  GpsInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpsInformation& from);
  void MergeFrom(const GpsInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 longitude = 1;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  inline ::google::protobuf::int32 longitude() const;
  inline void set_longitude(::google::protobuf::int32 value);

  // required int32 latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline ::google::protobuf::int32 latitude() const;
  inline void set_latitude(::google::protobuf::int32 value);

  // required int32 altitude = 3;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  inline ::google::protobuf::int32 altitude() const;
  inline void set_altitude(::google::protobuf::int32 value);

  // repeated float velocity = 4;
  inline int velocity_size() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  inline float velocity(int index) const;
  inline void set_velocity(int index, float value);
  inline void add_velocity(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      velocity() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_velocity();

  // @@protoc_insertion_point(class_scope:das.proto.GpsInformation)
 private:
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 longitude_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::RepeatedField< float > velocity_;
  ::google::protobuf::int32 altitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static GpsInformation* default_instance_;
};
// -------------------------------------------------------------------

class UavAttitude : public ::google::protobuf::Message {
 public:
  UavAttitude();
  virtual ~UavAttitude();

  UavAttitude(const UavAttitude& from);

  inline UavAttitude& operator=(const UavAttitude& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UavAttitude& default_instance();

  void Swap(UavAttitude* other);

  // implements Message ----------------------------------------------

  UavAttitude* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UavAttitude& from);
  void MergeFrom(const UavAttitude& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float roll = 1;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 1;
  inline float roll() const;
  inline void set_roll(float value);

  // required float pitch = 2;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 2;
  inline float pitch() const;
  inline void set_pitch(float value);

  // required float yaw = 3;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 3;
  inline float yaw() const;
  inline void set_yaw(float value);

  // required float relative_alt = 4;
  inline bool has_relative_alt() const;
  inline void clear_relative_alt();
  static const int kRelativeAltFieldNumber = 4;
  inline float relative_alt() const;
  inline void set_relative_alt(float value);

  // required float groundspeed = 5;
  inline bool has_groundspeed() const;
  inline void clear_groundspeed();
  static const int kGroundspeedFieldNumber = 5;
  inline float groundspeed() const;
  inline void set_groundspeed(float value);

  // @@protoc_insertion_point(class_scope:das.proto.UavAttitude)
 private:
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_relative_alt();
  inline void clear_has_relative_alt();
  inline void set_has_groundspeed();
  inline void clear_has_groundspeed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float roll_;
  float pitch_;
  float yaw_;
  float relative_alt_;
  float groundspeed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static UavAttitude* default_instance_;
};
// -------------------------------------------------------------------

class OperationStatus : public ::google::protobuf::Message {
 public:
  OperationStatus();
  virtual ~OperationStatus();

  OperationStatus(const OperationStatus& from);

  inline OperationStatus& operator=(const OperationStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationStatus& default_instance();

  void Swap(OperationStatus* other);

  // implements Message ----------------------------------------------

  OperationStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationStatus& from);
  void MergeFrom(const OperationStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string operationmode = 1;
  inline bool has_operationmode() const;
  inline void clear_operationmode();
  static const int kOperationmodeFieldNumber = 1;
  inline const ::std::string& operationmode() const;
  inline void set_operationmode(const ::std::string& value);
  inline void set_operationmode(const char* value);
  inline void set_operationmode(const char* value, size_t size);
  inline ::std::string* mutable_operationmode();
  inline ::std::string* release_operationmode();
  inline void set_allocated_operationmode(::std::string* operationmode);

  // optional float voltage = 2;
  inline bool has_voltage() const;
  inline void clear_voltage();
  static const int kVoltageFieldNumber = 2;
  inline float voltage() const;
  inline void set_voltage(float value);

  // optional float surplusenergy = 3;
  inline bool has_surplusenergy() const;
  inline void clear_surplusenergy();
  static const int kSurplusenergyFieldNumber = 3;
  inline float surplusenergy() const;
  inline void set_surplusenergy(float value);

  // optional float jetvelocity = 4;
  inline bool has_jetvelocity() const;
  inline void clear_jetvelocity();
  static const int kJetvelocityFieldNumber = 4;
  inline float jetvelocity() const;
  inline void set_jetvelocity(float value);

  // optional float sprayeddose = 5;
  inline bool has_sprayeddose() const;
  inline void clear_sprayeddose();
  static const int kSprayeddoseFieldNumber = 5;
  inline float sprayeddose() const;
  inline void set_sprayeddose(float value);

  // @@protoc_insertion_point(class_scope:das.proto.OperationStatus)
 private:
  inline void set_has_operationmode();
  inline void clear_has_operationmode();
  inline void set_has_voltage();
  inline void clear_has_voltage();
  inline void set_has_surplusenergy();
  inline void clear_has_surplusenergy();
  inline void set_has_jetvelocity();
  inline void clear_has_jetvelocity();
  inline void set_has_sprayeddose();
  inline void clear_has_sprayeddose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* operationmode_;
  float voltage_;
  float surplusenergy_;
  float jetvelocity_;
  float sprayeddose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationStatus* default_instance_;
};
// -------------------------------------------------------------------

class OperationParams : public ::google::protobuf::Message {
 public:
  OperationParams();
  virtual ~OperationParams();

  OperationParams(const OperationParams& from);

  inline OperationParams& operator=(const OperationParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationParams& default_instance();

  void Swap(OperationParams* other);

  // implements Message ----------------------------------------------

  OperationParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationParams& from);
  void MergeFrom(const OperationParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float alarmvoltage = 1;
  inline bool has_alarmvoltage() const;
  inline void clear_alarmvoltage();
  static const int kAlarmvoltageFieldNumber = 1;
  inline float alarmvoltage() const;
  inline void set_alarmvoltage(float value);

  // optional float alarmdose = 2;
  inline bool has_alarmdose() const;
  inline void clear_alarmdose();
  static const int kAlarmdoseFieldNumber = 2;
  inline float alarmdose() const;
  inline void set_alarmdose(float value);

  // optional float sprayingwidth = 3;
  inline bool has_sprayingwidth() const;
  inline void clear_sprayingwidth();
  static const int kSprayingwidthFieldNumber = 3;
  inline float sprayingwidth() const;
  inline void set_sprayingwidth(float value);

  // optional float desiredaltitude = 4;
  inline bool has_desiredaltitude() const;
  inline void clear_desiredaltitude();
  static const int kDesiredaltitudeFieldNumber = 4;
  inline float desiredaltitude() const;
  inline void set_desiredaltitude(float value);

  // optional float desiredvelocity = 5;
  inline bool has_desiredvelocity() const;
  inline void clear_desiredvelocity();
  static const int kDesiredvelocityFieldNumber = 5;
  inline float desiredvelocity() const;
  inline void set_desiredvelocity(float value);

  // optional float jetvelocity = 6;
  inline bool has_jetvelocity() const;
  inline void clear_jetvelocity();
  static const int kJetvelocityFieldNumber = 6;
  inline float jetvelocity() const;
  inline void set_jetvelocity(float value);

  // @@protoc_insertion_point(class_scope:das.proto.OperationParams)
 private:
  inline void set_has_alarmvoltage();
  inline void clear_has_alarmvoltage();
  inline void set_has_alarmdose();
  inline void clear_has_alarmdose();
  inline void set_has_sprayingwidth();
  inline void clear_has_sprayingwidth();
  inline void set_has_desiredaltitude();
  inline void clear_has_desiredaltitude();
  inline void set_has_desiredvelocity();
  inline void clear_has_desiredvelocity();
  inline void set_has_jetvelocity();
  inline void clear_has_jetvelocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float alarmvoltage_;
  float alarmdose_;
  float sprayingwidth_;
  float desiredaltitude_;
  float desiredvelocity_;
  float jetvelocity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationParams* default_instance_;
};
// -------------------------------------------------------------------

class OperationInformation : public ::google::protobuf::Message {
 public:
  OperationInformation();
  virtual ~OperationInformation();

  OperationInformation(const OperationInformation& from);

  inline OperationInformation& operator=(const OperationInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationInformation& default_instance();

  void Swap(OperationInformation* other);

  // implements Message ----------------------------------------------

  OperationInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationInformation& from);
  void MergeFrom(const OperationInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uavid = 1;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 1;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required .das.proto.GpsInformation gps = 3;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 3;
  inline const ::das::proto::GpsInformation& gps() const;
  inline ::das::proto::GpsInformation* mutable_gps();
  inline ::das::proto::GpsInformation* release_gps();
  inline void set_allocated_gps(::das::proto::GpsInformation* gps);

  // optional .das.proto.OperationStatus status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::das::proto::OperationStatus& status() const;
  inline ::das::proto::OperationStatus* mutable_status();
  inline ::das::proto::OperationStatus* release_status();
  inline void set_allocated_status(::das::proto::OperationStatus* status);

  // optional .das.proto.OperationParams params = 5;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 5;
  inline const ::das::proto::OperationParams& params() const;
  inline ::das::proto::OperationParams* mutable_params();
  inline ::das::proto::OperationParams* release_params();
  inline void set_allocated_params(::das::proto::OperationParams* params);

  // optional .das.proto.UavAttitude attitude = 6;
  inline bool has_attitude() const;
  inline void clear_attitude();
  static const int kAttitudeFieldNumber = 6;
  inline const ::das::proto::UavAttitude& attitude() const;
  inline ::das::proto::UavAttitude* mutable_attitude();
  inline ::das::proto::UavAttitude* release_attitude();
  inline void set_allocated_attitude(::das::proto::UavAttitude* attitude);

  // @@protoc_insertion_point(class_scope:das.proto.OperationInformation)
 private:
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_params();
  inline void clear_has_params();
  inline void set_has_attitude();
  inline void clear_has_attitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::google::protobuf::uint64 timestamp_;
  ::das::proto::GpsInformation* gps_;
  ::das::proto::OperationStatus* status_;
  ::das::proto::OperationParams* params_;
  ::das::proto::UavAttitude* attitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationInformation* default_instance_;
};
// -------------------------------------------------------------------

class PostOperationInformation : public ::google::protobuf::Message {
 public:
  PostOperationInformation();
  virtual ~PostOperationInformation();

  PostOperationInformation(const PostOperationInformation& from);

  inline PostOperationInformation& operator=(const PostOperationInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostOperationInformation& default_instance();

  void Swap(PostOperationInformation* other);

  // implements Message ----------------------------------------------

  PostOperationInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostOperationInformation& from);
  void MergeFrom(const PostOperationInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // repeated .das.proto.OperationInformation oi = 2;
  inline int oi_size() const;
  inline void clear_oi();
  static const int kOiFieldNumber = 2;
  inline const ::das::proto::OperationInformation& oi(int index) const;
  inline ::das::proto::OperationInformation* mutable_oi(int index);
  inline ::das::proto::OperationInformation* add_oi();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation >&
      oi() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation >*
      mutable_oi();

  // @@protoc_insertion_point(class_scope:das.proto.PostOperationInformation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation > oi_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostOperationInformation* default_instance_;
};
// -------------------------------------------------------------------

class AckOperationInformation : public ::google::protobuf::Message {
 public:
  AckOperationInformation();
  virtual ~AckOperationInformation();

  AckOperationInformation(const AckOperationInformation& from);

  inline AckOperationInformation& operator=(const AckOperationInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckOperationInformation& default_instance();

  void Swap(AckOperationInformation* other);

  // implements Message ----------------------------------------------

  AckOperationInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckOperationInformation& from);
  void MergeFrom(const AckOperationInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckOperationInformation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckOperationInformation* default_instance_;
};
// -------------------------------------------------------------------

class Coordinate : public ::google::protobuf::Message {
 public:
  Coordinate();
  virtual ~Coordinate();

  Coordinate(const Coordinate& from);

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coordinate& default_instance();

  void Swap(Coordinate* other);

  // implements Message ----------------------------------------------

  Coordinate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coordinate& from);
  void MergeFrom(const Coordinate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 longitude = 1;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  inline ::google::protobuf::int32 longitude() const;
  inline void set_longitude(::google::protobuf::int32 value);

  // required int32 latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline ::google::protobuf::int32 latitude() const;
  inline void set_latitude(::google::protobuf::int32 value);

  // optional int32 altitude = 3;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  inline ::google::protobuf::int32 altitude() const;
  inline void set_altitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.Coordinate)
 private:
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 longitude_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 altitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static Coordinate* default_instance_;
};
// -------------------------------------------------------------------

class OperationSnapshot : public ::google::protobuf::Message {
 public:
  OperationSnapshot();
  virtual ~OperationSnapshot();

  OperationSnapshot(const OperationSnapshot& from);

  inline OperationSnapshot& operator=(const OperationSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSnapshot& default_instance();

  void Swap(OperationSnapshot* other);

  // implements Message ----------------------------------------------

  OperationSnapshot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationSnapshot& from);
  void MergeFrom(const OperationSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string devid = 1;
  inline bool has_devid() const;
  inline void clear_devid();
  static const int kDevidFieldNumber = 1;
  inline const ::std::string& devid() const;
  inline void set_devid(const ::std::string& value);
  inline void set_devid(const char* value);
  inline void set_devid(const char* value, size_t size);
  inline ::std::string* mutable_devid();
  inline ::std::string* release_devid();
  inline void set_allocated_devid(::std::string* devid);

  // required uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional .das.proto.Coordinate pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline const ::das::proto::Coordinate& pos() const;
  inline ::das::proto::Coordinate* mutable_pos();
  inline ::das::proto::Coordinate* release_pos();
  inline void set_allocated_pos(::das::proto::Coordinate* pos);

  // optional int32 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // required bytes pic = 5;
  inline bool has_pic() const;
  inline void clear_pic();
  static const int kPicFieldNumber = 5;
  inline const ::std::string& pic() const;
  inline void set_pic(const ::std::string& value);
  inline void set_pic(const char* value);
  inline void set_pic(const void* value, size_t size);
  inline ::std::string* mutable_pic();
  inline ::std::string* release_pic();
  inline void set_allocated_pic(::std::string* pic);

  // @@protoc_insertion_point(class_scope:das.proto.OperationSnapshot)
 private:
  inline void set_has_devid();
  inline void clear_has_devid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_pic();
  inline void clear_has_pic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* devid_;
  ::google::protobuf::uint64 timestamp_;
  ::das::proto::Coordinate* pos_;
  ::std::string* pic_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationSnapshot* default_instance_;
};
// -------------------------------------------------------------------

class PostOperationSnapshot : public ::google::protobuf::Message {
 public:
  PostOperationSnapshot();
  virtual ~PostOperationSnapshot();

  PostOperationSnapshot(const PostOperationSnapshot& from);

  inline PostOperationSnapshot& operator=(const PostOperationSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostOperationSnapshot& default_instance();

  void Swap(PostOperationSnapshot* other);

  // implements Message ----------------------------------------------

  PostOperationSnapshot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostOperationSnapshot& from);
  void MergeFrom(const PostOperationSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required .das.proto.OperationSnapshot os = 2;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 2;
  inline const ::das::proto::OperationSnapshot& os() const;
  inline ::das::proto::OperationSnapshot* mutable_os();
  inline ::das::proto::OperationSnapshot* release_os();
  inline void set_allocated_os(::das::proto::OperationSnapshot* os);

  // @@protoc_insertion_point(class_scope:das.proto.PostOperationSnapshot)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_os();
  inline void clear_has_os();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::das::proto::OperationSnapshot* os_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostOperationSnapshot* default_instance_;
};
// -------------------------------------------------------------------

class AckPostOperationSnapshot : public ::google::protobuf::Message {
 public:
  AckPostOperationSnapshot();
  virtual ~AckPostOperationSnapshot();

  AckPostOperationSnapshot(const AckPostOperationSnapshot& from);

  inline AckPostOperationSnapshot& operator=(const AckPostOperationSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostOperationSnapshot& default_instance();

  void Swap(AckPostOperationSnapshot* other);

  // implements Message ----------------------------------------------

  AckPostOperationSnapshot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostOperationSnapshot& from);
  void MergeFrom(const AckPostOperationSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostOperationSnapshot)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostOperationSnapshot* default_instance_;
};
// -------------------------------------------------------------------

class Outline : public ::google::protobuf::Message {
 public:
  Outline();
  virtual ~Outline();

  Outline(const Outline& from);

  inline Outline& operator=(const Outline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Outline& default_instance();

  void Swap(Outline* other);

  // implements Message ----------------------------------------------

  Outline* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Outline& from);
  void MergeFrom(const Outline& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .das.proto.Coordinate coordinates = 1;
  inline int coordinates_size() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 1;
  inline const ::das::proto::Coordinate& coordinates(int index) const;
  inline ::das::proto::Coordinate* mutable_coordinates(int index);
  inline ::das::proto::Coordinate* add_coordinates();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate >&
      coordinates() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate >*
      mutable_coordinates();

  // @@protoc_insertion_point(class_scope:das.proto.Outline)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate > coordinates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static Outline* default_instance_;
};
// -------------------------------------------------------------------

class ParcelSurveyInformation : public ::google::protobuf::Message {
 public:
  ParcelSurveyInformation();
  virtual ~ParcelSurveyInformation();

  ParcelSurveyInformation(const ParcelSurveyInformation& from);

  inline ParcelSurveyInformation& operator=(const ParcelSurveyInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParcelSurveyInformation& default_instance();

  void Swap(ParcelSurveyInformation* other);

  // implements Message ----------------------------------------------

  ParcelSurveyInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParcelSurveyInformation& from);
  void MergeFrom(const ParcelSurveyInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string surveryorid = 1;
  inline bool has_surveryorid() const;
  inline void clear_surveryorid();
  static const int kSurveryoridFieldNumber = 1;
  inline const ::std::string& surveryorid() const;
  inline void set_surveryorid(const ::std::string& value);
  inline void set_surveryorid(const char* value);
  inline void set_surveryorid(const char* value, size_t size);
  inline ::std::string* mutable_surveryorid();
  inline ::std::string* release_surveryorid();
  inline void set_allocated_surveryorid(::std::string* surveryorid);

  // required uint64 surverytime = 2;
  inline bool has_surverytime() const;
  inline void clear_surverytime();
  static const int kSurverytimeFieldNumber = 2;
  inline ::google::protobuf::uint64 surverytime() const;
  inline void set_surverytime(::google::protobuf::uint64 value);

  // required .das.proto.SurveryPrecision sp = 3;
  inline bool has_sp() const;
  inline void clear_sp();
  static const int kSpFieldNumber = 3;
  inline ::das::proto::SurveryPrecision sp() const;
  inline void set_sp(::das::proto::SurveryPrecision value);

  // required .das.proto.Outline po = 4;
  inline bool has_po() const;
  inline void clear_po();
  static const int kPoFieldNumber = 4;
  inline const ::das::proto::Outline& po() const;
  inline ::das::proto::Outline* mutable_po();
  inline ::das::proto::Outline* release_po();
  inline void set_allocated_po(::das::proto::Outline* po);

  // repeated .das.proto.Outline bo = 5;
  inline int bo_size() const;
  inline void clear_bo();
  static const int kBoFieldNumber = 5;
  inline const ::das::proto::Outline& bo(int index) const;
  inline ::das::proto::Outline* mutable_bo(int index);
  inline ::das::proto::Outline* add_bo();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::Outline >&
      bo() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::Outline >*
      mutable_bo();

  // optional string id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:das.proto.ParcelSurveyInformation)
 private:
  inline void set_has_surveryorid();
  inline void clear_has_surveryorid();
  inline void set_has_surverytime();
  inline void clear_has_surverytime();
  inline void set_has_sp();
  inline void clear_has_sp();
  inline void set_has_po();
  inline void clear_has_po();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* surveryorid_;
  ::google::protobuf::uint64 surverytime_;
  ::das::proto::Outline* po_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::Outline > bo_;
  ::std::string* id_;
  int sp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static ParcelSurveyInformation* default_instance_;
};
// -------------------------------------------------------------------

class PostParcelSurveyInformation : public ::google::protobuf::Message {
 public:
  PostParcelSurveyInformation();
  virtual ~PostParcelSurveyInformation();

  PostParcelSurveyInformation(const PostParcelSurveyInformation& from);

  inline PostParcelSurveyInformation& operator=(const PostParcelSurveyInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostParcelSurveyInformation& default_instance();

  void Swap(PostParcelSurveyInformation* other);

  // implements Message ----------------------------------------------

  PostParcelSurveyInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostParcelSurveyInformation& from);
  void MergeFrom(const PostParcelSurveyInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required .das.proto.ParcelSurveyInformation psi = 2;
  inline bool has_psi() const;
  inline void clear_psi();
  static const int kPsiFieldNumber = 2;
  inline const ::das::proto::ParcelSurveyInformation& psi() const;
  inline ::das::proto::ParcelSurveyInformation* mutable_psi();
  inline ::das::proto::ParcelSurveyInformation* release_psi();
  inline void set_allocated_psi(::das::proto::ParcelSurveyInformation* psi);

  // @@protoc_insertion_point(class_scope:das.proto.PostParcelSurveyInformation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_psi();
  inline void clear_has_psi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::das::proto::ParcelSurveyInformation* psi_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostParcelSurveyInformation* default_instance_;
};
// -------------------------------------------------------------------

class AckPostParcelSurveyInformation : public ::google::protobuf::Message {
 public:
  AckPostParcelSurveyInformation();
  virtual ~AckPostParcelSurveyInformation();

  AckPostParcelSurveyInformation(const AckPostParcelSurveyInformation& from);

  inline AckPostParcelSurveyInformation& operator=(const AckPostParcelSurveyInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostParcelSurveyInformation& default_instance();

  void Swap(AckPostParcelSurveyInformation* other);

  // implements Message ----------------------------------------------

  AckPostParcelSurveyInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostParcelSurveyInformation& from);
  void MergeFrom(const AckPostParcelSurveyInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string psiid = 3;
  inline bool has_psiid() const;
  inline void clear_psiid();
  static const int kPsiidFieldNumber = 3;
  inline const ::std::string& psiid() const;
  inline void set_psiid(const ::std::string& value);
  inline void set_psiid(const char* value);
  inline void set_psiid(const char* value, size_t size);
  inline ::std::string* mutable_psiid();
  inline ::std::string* release_psiid();
  inline void set_allocated_psiid(::std::string* psiid);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostParcelSurveyInformation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_psiid();
  inline void clear_has_psiid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* psiid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostParcelSurveyInformation* default_instance_;
};
// -------------------------------------------------------------------

class RequestParcelSurveyInformations : public ::google::protobuf::Message {
 public:
  RequestParcelSurveyInformations();
  virtual ~RequestParcelSurveyInformations();

  RequestParcelSurveyInformations(const RequestParcelSurveyInformations& from);

  inline RequestParcelSurveyInformations& operator=(const RequestParcelSurveyInformations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestParcelSurveyInformations& default_instance();

  void Swap(RequestParcelSurveyInformations* other);

  // implements Message ----------------------------------------------

  RequestParcelSurveyInformations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestParcelSurveyInformations& from);
  void MergeFrom(const RequestParcelSurveyInformations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional string psiid = 2;
  inline bool has_psiid() const;
  inline void clear_psiid();
  static const int kPsiidFieldNumber = 2;
  inline const ::std::string& psiid() const;
  inline void set_psiid(const ::std::string& value);
  inline void set_psiid(const char* value);
  inline void set_psiid(const char* value, size_t size);
  inline ::std::string* mutable_psiid();
  inline ::std::string* release_psiid();
  inline void set_allocated_psiid(::std::string* psiid);

  // optional .das.proto.Coordinate coordinate = 3;
  inline bool has_coordinate() const;
  inline void clear_coordinate();
  static const int kCoordinateFieldNumber = 3;
  inline const ::das::proto::Coordinate& coordinate() const;
  inline ::das::proto::Coordinate* mutable_coordinate();
  inline ::das::proto::Coordinate* release_coordinate();
  inline void set_allocated_coordinate(::das::proto::Coordinate* coordinate);

  // @@protoc_insertion_point(class_scope:das.proto.RequestParcelSurveyInformations)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_psiid();
  inline void clear_has_psiid();
  inline void set_has_coordinate();
  inline void clear_has_coordinate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* psiid_;
  ::das::proto::Coordinate* coordinate_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestParcelSurveyInformations* default_instance_;
};
// -------------------------------------------------------------------

class AckRequestParcelSurveyInformations : public ::google::protobuf::Message {
 public:
  AckRequestParcelSurveyInformations();
  virtual ~AckRequestParcelSurveyInformations();

  AckRequestParcelSurveyInformations(const AckRequestParcelSurveyInformations& from);

  inline AckRequestParcelSurveyInformations& operator=(const AckRequestParcelSurveyInformations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRequestParcelSurveyInformations& default_instance();

  void Swap(AckRequestParcelSurveyInformations* other);

  // implements Message ----------------------------------------------

  AckRequestParcelSurveyInformations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRequestParcelSurveyInformations& from);
  void MergeFrom(const AckRequestParcelSurveyInformations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .das.proto.ParcelSurveyInformation psis = 3;
  inline int psis_size() const;
  inline void clear_psis();
  static const int kPsisFieldNumber = 3;
  inline const ::das::proto::ParcelSurveyInformation& psis(int index) const;
  inline ::das::proto::ParcelSurveyInformation* mutable_psis(int index);
  inline ::das::proto::ParcelSurveyInformation* add_psis();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelSurveyInformation >&
      psis() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelSurveyInformation >*
      mutable_psis();

  // @@protoc_insertion_point(class_scope:das.proto.AckRequestParcelSurveyInformations)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelSurveyInformation > psis_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckRequestParcelSurveyInformations* default_instance_;
};
// -------------------------------------------------------------------

class ParcelContracter : public ::google::protobuf::Message {
 public:
  ParcelContracter();
  virtual ~ParcelContracter();

  ParcelContracter(const ParcelContracter& from);

  inline ParcelContracter& operator=(const ParcelContracter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParcelContracter& default_instance();

  void Swap(ParcelContracter* other);

  // implements Message ----------------------------------------------

  ParcelContracter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParcelContracter& from);
  void MergeFrom(const ParcelContracter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint64 birthdate = 2;
  inline bool has_birthdate() const;
  inline void clear_birthdate();
  static const int kBirthdateFieldNumber = 2;
  inline ::google::protobuf::uint64 birthdate() const;
  inline void set_birthdate(::google::protobuf::uint64 value);

  // required string address = 3;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // required string mobileno = 4;
  inline bool has_mobileno() const;
  inline void clear_mobileno();
  static const int kMobilenoFieldNumber = 4;
  inline const ::std::string& mobileno() const;
  inline void set_mobileno(const ::std::string& value);
  inline void set_mobileno(const char* value);
  inline void set_mobileno(const char* value, size_t size);
  inline ::std::string* mutable_mobileno();
  inline ::std::string* release_mobileno();
  inline void set_allocated_mobileno(::std::string* mobileno);

  // optional string phoneno = 5;
  inline bool has_phoneno() const;
  inline void clear_phoneno();
  static const int kPhonenoFieldNumber = 5;
  inline const ::std::string& phoneno() const;
  inline void set_phoneno(const ::std::string& value);
  inline void set_phoneno(const char* value);
  inline void set_phoneno(const char* value, size_t size);
  inline ::std::string* mutable_phoneno();
  inline ::std::string* release_phoneno();
  inline void set_allocated_phoneno(::std::string* phoneno);

  // optional string weixin = 6;
  inline bool has_weixin() const;
  inline void clear_weixin();
  static const int kWeixinFieldNumber = 6;
  inline const ::std::string& weixin() const;
  inline void set_weixin(const ::std::string& value);
  inline void set_weixin(const char* value);
  inline void set_weixin(const char* value, size_t size);
  inline ::std::string* mutable_weixin();
  inline ::std::string* release_weixin();
  inline void set_allocated_weixin(::std::string* weixin);

  // optional string id = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 7;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:das.proto.ParcelContracter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_birthdate();
  inline void clear_has_birthdate();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_mobileno();
  inline void clear_has_mobileno();
  inline void set_has_phoneno();
  inline void clear_has_phoneno();
  inline void set_has_weixin();
  inline void clear_has_weixin();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 birthdate_;
  ::std::string* address_;
  ::std::string* mobileno_;
  ::std::string* phoneno_;
  ::std::string* weixin_;
  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static ParcelContracter* default_instance_;
};
// -------------------------------------------------------------------

class ParcelDescription : public ::google::protobuf::Message {
 public:
  ParcelDescription();
  virtual ~ParcelDescription();

  ParcelDescription(const ParcelDescription& from);

  inline ParcelDescription& operator=(const ParcelDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParcelDescription& default_instance();

  void Swap(ParcelDescription* other);

  // implements Message ----------------------------------------------

  ParcelDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParcelDescription& from);
  void MergeFrom(const ParcelDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string registerid = 2;
  inline bool has_registerid() const;
  inline void clear_registerid();
  static const int kRegisteridFieldNumber = 2;
  inline const ::std::string& registerid() const;
  inline void set_registerid(const ::std::string& value);
  inline void set_registerid(const char* value);
  inline void set_registerid(const char* value, size_t size);
  inline ::std::string* mutable_registerid();
  inline ::std::string* release_registerid();
  inline void set_allocated_registerid(::std::string* registerid);

  // required .das.proto.ParcelContracter pc = 3;
  inline bool has_pc() const;
  inline void clear_pc();
  static const int kPcFieldNumber = 3;
  inline const ::das::proto::ParcelContracter& pc() const;
  inline ::das::proto::ParcelContracter* mutable_pc();
  inline ::das::proto::ParcelContracter* release_pc();
  inline void set_allocated_pc(::das::proto::ParcelContracter* pc);

  // required float acreage = 4;
  inline bool has_acreage() const;
  inline void clear_acreage();
  static const int kAcreageFieldNumber = 4;
  inline float acreage() const;
  inline void set_acreage(float value);

  // optional string psiid = 5;
  inline bool has_psiid() const;
  inline void clear_psiid();
  static const int kPsiidFieldNumber = 5;
  inline const ::std::string& psiid() const;
  inline void set_psiid(const ::std::string& value);
  inline void set_psiid(const char* value);
  inline void set_psiid(const char* value, size_t size);
  inline ::std::string* mutable_psiid();
  inline ::std::string* release_psiid();
  inline void set_allocated_psiid(::std::string* psiid);

  // optional .das.proto.ParcelSurveyInformation psi = 6;
  inline bool has_psi() const;
  inline void clear_psi();
  static const int kPsiFieldNumber = 6;
  inline const ::das::proto::ParcelSurveyInformation& psi() const;
  inline ::das::proto::ParcelSurveyInformation* mutable_psi();
  inline ::das::proto::ParcelSurveyInformation* release_psi();
  inline void set_allocated_psi(::das::proto::ParcelSurveyInformation* psi);

  // optional .das.proto.Coordinate coordinate = 7;
  inline bool has_coordinate() const;
  inline void clear_coordinate();
  static const int kCoordinateFieldNumber = 7;
  inline const ::das::proto::Coordinate& coordinate() const;
  inline ::das::proto::Coordinate* mutable_coordinate();
  inline ::das::proto::Coordinate* release_coordinate();
  inline void set_allocated_coordinate(::das::proto::Coordinate* coordinate);

  // optional string id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:das.proto.ParcelDescription)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_registerid();
  inline void clear_has_registerid();
  inline void set_has_pc();
  inline void clear_has_pc();
  inline void set_has_acreage();
  inline void clear_has_acreage();
  inline void set_has_psiid();
  inline void clear_has_psiid();
  inline void set_has_psi();
  inline void clear_has_psi();
  inline void set_has_coordinate();
  inline void clear_has_coordinate();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* registerid_;
  ::das::proto::ParcelContracter* pc_;
  ::std::string* psiid_;
  ::das::proto::ParcelSurveyInformation* psi_;
  ::das::proto::Coordinate* coordinate_;
  ::std::string* id_;
  float acreage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static ParcelDescription* default_instance_;
};
// -------------------------------------------------------------------

class PostParcelDescription : public ::google::protobuf::Message {
 public:
  PostParcelDescription();
  virtual ~PostParcelDescription();

  PostParcelDescription(const PostParcelDescription& from);

  inline PostParcelDescription& operator=(const PostParcelDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostParcelDescription& default_instance();

  void Swap(PostParcelDescription* other);

  // implements Message ----------------------------------------------

  PostParcelDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostParcelDescription& from);
  void MergeFrom(const PostParcelDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required .das.proto.ParcelDescription pd = 2;
  inline bool has_pd() const;
  inline void clear_pd();
  static const int kPdFieldNumber = 2;
  inline const ::das::proto::ParcelDescription& pd() const;
  inline ::das::proto::ParcelDescription* mutable_pd();
  inline ::das::proto::ParcelDescription* release_pd();
  inline void set_allocated_pd(::das::proto::ParcelDescription* pd);

  // @@protoc_insertion_point(class_scope:das.proto.PostParcelDescription)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_pd();
  inline void clear_has_pd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::das::proto::ParcelDescription* pd_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostParcelDescription* default_instance_;
};
// -------------------------------------------------------------------

class AckPostParcelDescription : public ::google::protobuf::Message {
 public:
  AckPostParcelDescription();
  virtual ~AckPostParcelDescription();

  AckPostParcelDescription(const AckPostParcelDescription& from);

  inline AckPostParcelDescription& operator=(const AckPostParcelDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostParcelDescription& default_instance();

  void Swap(AckPostParcelDescription* other);

  // implements Message ----------------------------------------------

  AckPostParcelDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostParcelDescription& from);
  void MergeFrom(const AckPostParcelDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string pcid = 3;
  inline bool has_pcid() const;
  inline void clear_pcid();
  static const int kPcidFieldNumber = 3;
  inline const ::std::string& pcid() const;
  inline void set_pcid(const ::std::string& value);
  inline void set_pcid(const char* value);
  inline void set_pcid(const char* value, size_t size);
  inline ::std::string* mutable_pcid();
  inline ::std::string* release_pcid();
  inline void set_allocated_pcid(::std::string* pcid);

  // optional string psiid = 4;
  inline bool has_psiid() const;
  inline void clear_psiid();
  static const int kPsiidFieldNumber = 4;
  inline const ::std::string& psiid() const;
  inline void set_psiid(const ::std::string& value);
  inline void set_psiid(const char* value);
  inline void set_psiid(const char* value, size_t size);
  inline ::std::string* mutable_psiid();
  inline ::std::string* release_psiid();
  inline void set_allocated_psiid(::std::string* psiid);

  // optional string pdid = 5;
  inline bool has_pdid() const;
  inline void clear_pdid();
  static const int kPdidFieldNumber = 5;
  inline const ::std::string& pdid() const;
  inline void set_pdid(const ::std::string& value);
  inline void set_pdid(const char* value);
  inline void set_pdid(const char* value, size_t size);
  inline ::std::string* mutable_pdid();
  inline ::std::string* release_pdid();
  inline void set_allocated_pdid(::std::string* pdid);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostParcelDescription)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_pcid();
  inline void clear_has_pcid();
  inline void set_has_psiid();
  inline void clear_has_psiid();
  inline void set_has_pdid();
  inline void clear_has_pdid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* pcid_;
  ::std::string* psiid_;
  ::std::string* pdid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostParcelDescription* default_instance_;
};
// -------------------------------------------------------------------

class RequestParcelDescriptions : public ::google::protobuf::Message {
 public:
  RequestParcelDescriptions();
  virtual ~RequestParcelDescriptions();

  RequestParcelDescriptions(const RequestParcelDescriptions& from);

  inline RequestParcelDescriptions& operator=(const RequestParcelDescriptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestParcelDescriptions& default_instance();

  void Swap(RequestParcelDescriptions* other);

  // implements Message ----------------------------------------------

  RequestParcelDescriptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestParcelDescriptions& from);
  void MergeFrom(const RequestParcelDescriptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional string pdid = 2;
  inline bool has_pdid() const;
  inline void clear_pdid();
  static const int kPdidFieldNumber = 2;
  inline const ::std::string& pdid() const;
  inline void set_pdid(const ::std::string& value);
  inline void set_pdid(const char* value);
  inline void set_pdid(const char* value, size_t size);
  inline ::std::string* mutable_pdid();
  inline ::std::string* release_pdid();
  inline void set_allocated_pdid(::std::string* pdid);

  // optional .das.proto.Coordinate coordinate = 3;
  inline bool has_coordinate() const;
  inline void clear_coordinate();
  static const int kCoordinateFieldNumber = 3;
  inline const ::das::proto::Coordinate& coordinate() const;
  inline ::das::proto::Coordinate* mutable_coordinate();
  inline ::das::proto::Coordinate* release_coordinate();
  inline void set_allocated_coordinate(::das::proto::Coordinate* coordinate);

  // optional string surveryorname = 4;
  inline bool has_surveryorname() const;
  inline void clear_surveryorname();
  static const int kSurveryornameFieldNumber = 4;
  inline const ::std::string& surveryorname() const;
  inline void set_surveryorname(const ::std::string& value);
  inline void set_surveryorname(const char* value);
  inline void set_surveryorname(const char* value, size_t size);
  inline ::std::string* mutable_surveryorname();
  inline ::std::string* release_surveryorname();
  inline void set_allocated_surveryorname(::std::string* surveryorname);

  // optional string surveryorid = 5;
  inline bool has_surveryorid() const;
  inline void clear_surveryorid();
  static const int kSurveryoridFieldNumber = 5;
  inline const ::std::string& surveryorid() const;
  inline void set_surveryorid(const ::std::string& value);
  inline void set_surveryorid(const char* value);
  inline void set_surveryorid(const char* value, size_t size);
  inline ::std::string* mutable_surveryorid();
  inline ::std::string* release_surveryorid();
  inline void set_allocated_surveryorid(::std::string* surveryorid);

  // optional string registername = 6;
  inline bool has_registername() const;
  inline void clear_registername();
  static const int kRegisternameFieldNumber = 6;
  inline const ::std::string& registername() const;
  inline void set_registername(const ::std::string& value);
  inline void set_registername(const char* value);
  inline void set_registername(const char* value, size_t size);
  inline ::std::string* mutable_registername();
  inline ::std::string* release_registername();
  inline void set_allocated_registername(::std::string* registername);

  // optional string registerid = 7;
  inline bool has_registerid() const;
  inline void clear_registerid();
  static const int kRegisteridFieldNumber = 7;
  inline const ::std::string& registerid() const;
  inline void set_registerid(const ::std::string& value);
  inline void set_registerid(const char* value);
  inline void set_registerid(const char* value, size_t size);
  inline ::std::string* mutable_registerid();
  inline ::std::string* release_registerid();
  inline void set_allocated_registerid(::std::string* registerid);

  // optional string parcelname = 8;
  inline bool has_parcelname() const;
  inline void clear_parcelname();
  static const int kParcelnameFieldNumber = 8;
  inline const ::std::string& parcelname() const;
  inline void set_parcelname(const ::std::string& value);
  inline void set_parcelname(const char* value);
  inline void set_parcelname(const char* value, size_t size);
  inline ::std::string* mutable_parcelname();
  inline ::std::string* release_parcelname();
  inline void set_allocated_parcelname(::std::string* parcelname);

  // optional string contracter = 9;
  inline bool has_contracter() const;
  inline void clear_contracter();
  static const int kContracterFieldNumber = 9;
  inline const ::std::string& contracter() const;
  inline void set_contracter(const ::std::string& value);
  inline void set_contracter(const char* value);
  inline void set_contracter(const char* value, size_t size);
  inline ::std::string* mutable_contracter();
  inline ::std::string* release_contracter();
  inline void set_allocated_contracter(::std::string* contracter);

  // optional string mobileno = 10;
  inline bool has_mobileno() const;
  inline void clear_mobileno();
  static const int kMobilenoFieldNumber = 10;
  inline const ::std::string& mobileno() const;
  inline void set_mobileno(const ::std::string& value);
  inline void set_mobileno(const char* value);
  inline void set_mobileno(const char* value, size_t size);
  inline ::std::string* mutable_mobileno();
  inline ::std::string* release_mobileno();
  inline void set_allocated_mobileno(::std::string* mobileno);

  // repeated .das.proto.Coordinate zones = 11;
  inline int zones_size() const;
  inline void clear_zones();
  static const int kZonesFieldNumber = 11;
  inline const ::das::proto::Coordinate& zones(int index) const;
  inline ::das::proto::Coordinate* mutable_zones(int index);
  inline ::das::proto::Coordinate* add_zones();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate >&
      zones() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate >*
      mutable_zones();

  // @@protoc_insertion_point(class_scope:das.proto.RequestParcelDescriptions)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_pdid();
  inline void clear_has_pdid();
  inline void set_has_coordinate();
  inline void clear_has_coordinate();
  inline void set_has_surveryorname();
  inline void clear_has_surveryorname();
  inline void set_has_surveryorid();
  inline void clear_has_surveryorid();
  inline void set_has_registername();
  inline void clear_has_registername();
  inline void set_has_registerid();
  inline void clear_has_registerid();
  inline void set_has_parcelname();
  inline void clear_has_parcelname();
  inline void set_has_contracter();
  inline void clear_has_contracter();
  inline void set_has_mobileno();
  inline void clear_has_mobileno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pdid_;
  ::das::proto::Coordinate* coordinate_;
  ::std::string* surveryorname_;
  ::std::string* surveryorid_;
  ::std::string* registername_;
  ::std::string* registerid_;
  ::std::string* parcelname_;
  ::std::string* contracter_;
  ::std::string* mobileno_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate > zones_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestParcelDescriptions* default_instance_;
};
// -------------------------------------------------------------------

class AckRequestParcelDescriptions : public ::google::protobuf::Message {
 public:
  AckRequestParcelDescriptions();
  virtual ~AckRequestParcelDescriptions();

  AckRequestParcelDescriptions(const AckRequestParcelDescriptions& from);

  inline AckRequestParcelDescriptions& operator=(const AckRequestParcelDescriptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRequestParcelDescriptions& default_instance();

  void Swap(AckRequestParcelDescriptions* other);

  // implements Message ----------------------------------------------

  AckRequestParcelDescriptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRequestParcelDescriptions& from);
  void MergeFrom(const AckRequestParcelDescriptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .das.proto.ParcelDescription pds = 3;
  inline int pds_size() const;
  inline void clear_pds();
  static const int kPdsFieldNumber = 3;
  inline const ::das::proto::ParcelDescription& pds(int index) const;
  inline ::das::proto::ParcelDescription* mutable_pds(int index);
  inline ::das::proto::ParcelDescription* add_pds();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelDescription >&
      pds() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelDescription >*
      mutable_pds();

  // @@protoc_insertion_point(class_scope:das.proto.AckRequestParcelDescriptions)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelDescription > pds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckRequestParcelDescriptions* default_instance_;
};
// -------------------------------------------------------------------

class DeleteParcelDescription : public ::google::protobuf::Message {
 public:
  DeleteParcelDescription();
  virtual ~DeleteParcelDescription();

  DeleteParcelDescription(const DeleteParcelDescription& from);

  inline DeleteParcelDescription& operator=(const DeleteParcelDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteParcelDescription& default_instance();

  void Swap(DeleteParcelDescription* other);

  // implements Message ----------------------------------------------

  DeleteParcelDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteParcelDescription& from);
  void MergeFrom(const DeleteParcelDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string pdid = 2;
  inline bool has_pdid() const;
  inline void clear_pdid();
  static const int kPdidFieldNumber = 2;
  inline const ::std::string& pdid() const;
  inline void set_pdid(const ::std::string& value);
  inline void set_pdid(const char* value);
  inline void set_pdid(const char* value, size_t size);
  inline ::std::string* mutable_pdid();
  inline ::std::string* release_pdid();
  inline void set_allocated_pdid(::std::string* pdid);

  // optional bool delpsi = 3;
  inline bool has_delpsi() const;
  inline void clear_delpsi();
  static const int kDelpsiFieldNumber = 3;
  inline bool delpsi() const;
  inline void set_delpsi(bool value);

  // optional bool delpc = 4;
  inline bool has_delpc() const;
  inline void clear_delpc();
  static const int kDelpcFieldNumber = 4;
  inline bool delpc() const;
  inline void set_delpc(bool value);

  // @@protoc_insertion_point(class_scope:das.proto.DeleteParcelDescription)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_pdid();
  inline void clear_has_pdid();
  inline void set_has_delpsi();
  inline void clear_has_delpsi();
  inline void set_has_delpc();
  inline void clear_has_delpc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pdid_;
  ::google::protobuf::uint32 seqno_;
  bool delpsi_;
  bool delpc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static DeleteParcelDescription* default_instance_;
};
// -------------------------------------------------------------------

class AckDeleteParcelDescription : public ::google::protobuf::Message {
 public:
  AckDeleteParcelDescription();
  virtual ~AckDeleteParcelDescription();

  AckDeleteParcelDescription(const AckDeleteParcelDescription& from);

  inline AckDeleteParcelDescription& operator=(const AckDeleteParcelDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckDeleteParcelDescription& default_instance();

  void Swap(AckDeleteParcelDescription* other);

  // implements Message ----------------------------------------------

  AckDeleteParcelDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckDeleteParcelDescription& from);
  void MergeFrom(const AckDeleteParcelDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckDeleteParcelDescription)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckDeleteParcelDescription* default_instance_;
};
// -------------------------------------------------------------------

class SingleShrink : public ::google::protobuf::Message {
 public:
  SingleShrink();
  virtual ~SingleShrink();

  SingleShrink(const SingleShrink& from);

  inline SingleShrink& operator=(const SingleShrink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleShrink& default_instance();

  void Swap(SingleShrink* other);

  // implements Message ----------------------------------------------

  SingleShrink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleShrink& from);
  void MergeFrom(const SingleShrink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 bdr = 1;
  inline bool has_bdr() const;
  inline void clear_bdr();
  static const int kBdrFieldNumber = 1;
  inline ::google::protobuf::int32 bdr() const;
  inline void set_bdr(::google::protobuf::int32 value);

  // required double safe = 2;
  inline bool has_safe() const;
  inline void clear_safe();
  static const int kSafeFieldNumber = 2;
  inline double safe() const;
  inline void set_safe(double value);

  // @@protoc_insertion_point(class_scope:das.proto.SingleShrink)
 private:
  inline void set_has_bdr();
  inline void clear_has_bdr();
  inline void set_has_safe();
  inline void clear_has_safe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double safe_;
  ::google::protobuf::int32 bdr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static SingleShrink* default_instance_;
};
// -------------------------------------------------------------------

class OperationPlan : public ::google::protobuf::Message {
 public:
  OperationPlan();
  virtual ~OperationPlan();

  OperationPlan(const OperationPlan& from);

  inline OperationPlan& operator=(const OperationPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationPlan& default_instance();

  void Swap(OperationPlan* other);

  // implements Message ----------------------------------------------

  OperationPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationPlan& from);
  void MergeFrom(const OperationPlan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline double width() const;
  inline void set_width(double value);

  // required float angle = 2;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 2;
  inline float angle() const;
  inline void set_angle(float value);

  // required bool anti = 3;
  inline bool has_anti() const;
  inline void clear_anti();
  static const int kAntiFieldNumber = 3;
  inline bool anti() const;
  inline void set_anti(bool value);

  // required bool single = 4;
  inline bool has_single() const;
  inline void clear_single();
  static const int kSingleFieldNumber = 4;
  inline bool single() const;
  inline void set_single(bool value);

  // repeated .das.proto.SingleShrink bdrsafe = 5;
  inline int bdrsafe_size() const;
  inline void clear_bdrsafe();
  static const int kBdrsafeFieldNumber = 5;
  inline const ::das::proto::SingleShrink& bdrsafe(int index) const;
  inline ::das::proto::SingleShrink* mutable_bdrsafe(int index);
  inline ::das::proto::SingleShrink* add_bdrsafe();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::SingleShrink >&
      bdrsafe() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::SingleShrink >*
      mutable_bdrsafe();

  // required double block = 6;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 6;
  inline double block() const;
  inline void set_block(double value);

  // @@protoc_insertion_point(class_scope:das.proto.OperationPlan)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_anti();
  inline void clear_has_anti();
  inline void set_has_single();
  inline void clear_has_single();
  inline void set_has_block();
  inline void clear_has_block();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double width_;
  float angle_;
  bool anti_;
  bool single_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::SingleShrink > bdrsafe_;
  double block_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationPlan* default_instance_;
};
// -------------------------------------------------------------------

class OperationDescription : public ::google::protobuf::Message {
 public:
  OperationDescription();
  virtual ~OperationDescription();

  OperationDescription(const OperationDescription& from);

  inline OperationDescription& operator=(const OperationDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationDescription& default_instance();

  void Swap(OperationDescription* other);

  // implements Message ----------------------------------------------

  OperationDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationDescription& from);
  void MergeFrom(const OperationDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string registerid = 1;
  inline bool has_registerid() const;
  inline void clear_registerid();
  static const int kRegisteridFieldNumber = 1;
  inline const ::std::string& registerid() const;
  inline void set_registerid(const ::std::string& value);
  inline void set_registerid(const char* value);
  inline void set_registerid(const char* value, size_t size);
  inline ::std::string* mutable_registerid();
  inline ::std::string* release_registerid();
  inline void set_allocated_registerid(::std::string* registerid);

  // required string pdid = 2;
  inline bool has_pdid() const;
  inline void clear_pdid();
  static const int kPdidFieldNumber = 2;
  inline const ::std::string& pdid() const;
  inline void set_pdid(const ::std::string& value);
  inline void set_pdid(const char* value);
  inline void set_pdid(const char* value, size_t size);
  inline ::std::string* mutable_pdid();
  inline ::std::string* release_pdid();
  inline void set_allocated_pdid(::std::string* pdid);

  // required .das.proto.OperationPlan op = 3;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 3;
  inline const ::das::proto::OperationPlan& op() const;
  inline ::das::proto::OperationPlan* mutable_op();
  inline ::das::proto::OperationPlan* release_op();
  inline void set_allocated_op(::das::proto::OperationPlan* op);

  // required string crop = 4;
  inline bool has_crop() const;
  inline void clear_crop();
  static const int kCropFieldNumber = 4;
  inline const ::std::string& crop() const;
  inline void set_crop(const ::std::string& value);
  inline void set_crop(const char* value);
  inline void set_crop(const char* value, size_t size);
  inline ::std::string* mutable_crop();
  inline ::std::string* release_crop();
  inline void set_allocated_crop(::std::string* crop);

  // required string drug = 5;
  inline bool has_drug() const;
  inline void clear_drug();
  static const int kDrugFieldNumber = 5;
  inline const ::std::string& drug() const;
  inline void set_drug(const ::std::string& value);
  inline void set_drug(const char* value);
  inline void set_drug(const char* value, size_t size);
  inline ::std::string* mutable_drug();
  inline ::std::string* release_drug();
  inline void set_allocated_drug(::std::string* drug);

  // required float prize = 6;
  inline bool has_prize() const;
  inline void clear_prize();
  static const int kPrizeFieldNumber = 6;
  inline float prize() const;
  inline void set_prize(float value);

  // optional uint64 plantime = 7;
  inline bool has_plantime() const;
  inline void clear_plantime();
  static const int kPlantimeFieldNumber = 7;
  inline ::google::protobuf::uint64 plantime() const;
  inline void set_plantime(::google::protobuf::uint64 value);

  // optional string notes = 8;
  inline bool has_notes() const;
  inline void clear_notes();
  static const int kNotesFieldNumber = 8;
  inline const ::std::string& notes() const;
  inline void set_notes(const ::std::string& value);
  inline void set_notes(const char* value);
  inline void set_notes(const char* value, size_t size);
  inline ::std::string* mutable_notes();
  inline ::std::string* release_notes();
  inline void set_allocated_notes(::std::string* notes);

  // optional string odid = 9;
  inline bool has_odid() const;
  inline void clear_odid();
  static const int kOdidFieldNumber = 9;
  inline const ::std::string& odid() const;
  inline void set_odid(const ::std::string& value);
  inline void set_odid(const char* value);
  inline void set_odid(const char* value, size_t size);
  inline ::std::string* mutable_odid();
  inline ::std::string* release_odid();
  inline void set_allocated_odid(::std::string* odid);

  // @@protoc_insertion_point(class_scope:das.proto.OperationDescription)
 private:
  inline void set_has_registerid();
  inline void clear_has_registerid();
  inline void set_has_pdid();
  inline void clear_has_pdid();
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_crop();
  inline void clear_has_crop();
  inline void set_has_drug();
  inline void clear_has_drug();
  inline void set_has_prize();
  inline void clear_has_prize();
  inline void set_has_plantime();
  inline void clear_has_plantime();
  inline void set_has_notes();
  inline void clear_has_notes();
  inline void set_has_odid();
  inline void clear_has_odid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* registerid_;
  ::std::string* pdid_;
  ::das::proto::OperationPlan* op_;
  ::std::string* crop_;
  ::std::string* drug_;
  ::google::protobuf::uint64 plantime_;
  ::std::string* notes_;
  ::std::string* odid_;
  float prize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationDescription* default_instance_;
};
// -------------------------------------------------------------------

class PostOperationDescription : public ::google::protobuf::Message {
 public:
  PostOperationDescription();
  virtual ~PostOperationDescription();

  PostOperationDescription(const PostOperationDescription& from);

  inline PostOperationDescription& operator=(const PostOperationDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostOperationDescription& default_instance();

  void Swap(PostOperationDescription* other);

  // implements Message ----------------------------------------------

  PostOperationDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostOperationDescription& from);
  void MergeFrom(const PostOperationDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required .das.proto.OperationDescription od = 2;
  inline bool has_od() const;
  inline void clear_od();
  static const int kOdFieldNumber = 2;
  inline const ::das::proto::OperationDescription& od() const;
  inline ::das::proto::OperationDescription* mutable_od();
  inline ::das::proto::OperationDescription* release_od();
  inline void set_allocated_od(::das::proto::OperationDescription* od);

  // @@protoc_insertion_point(class_scope:das.proto.PostOperationDescription)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_od();
  inline void clear_has_od();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::das::proto::OperationDescription* od_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostOperationDescription* default_instance_;
};
// -------------------------------------------------------------------

class AckPostOperationDescription : public ::google::protobuf::Message {
 public:
  AckPostOperationDescription();
  virtual ~AckPostOperationDescription();

  AckPostOperationDescription(const AckPostOperationDescription& from);

  inline AckPostOperationDescription& operator=(const AckPostOperationDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostOperationDescription& default_instance();

  void Swap(AckPostOperationDescription* other);

  // implements Message ----------------------------------------------

  AckPostOperationDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostOperationDescription& from);
  void MergeFrom(const AckPostOperationDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string odid = 3;
  inline bool has_odid() const;
  inline void clear_odid();
  static const int kOdidFieldNumber = 3;
  inline const ::std::string& odid() const;
  inline void set_odid(const ::std::string& value);
  inline void set_odid(const char* value);
  inline void set_odid(const char* value, size_t size);
  inline ::std::string* mutable_odid();
  inline ::std::string* release_odid();
  inline void set_allocated_odid(::std::string* odid);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostOperationDescription)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_odid();
  inline void clear_has_odid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* odid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostOperationDescription* default_instance_;
};
// -------------------------------------------------------------------

class RequestOperationDescriptions : public ::google::protobuf::Message {
 public:
  RequestOperationDescriptions();
  virtual ~RequestOperationDescriptions();

  RequestOperationDescriptions(const RequestOperationDescriptions& from);

  inline RequestOperationDescriptions& operator=(const RequestOperationDescriptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestOperationDescriptions& default_instance();

  void Swap(RequestOperationDescriptions* other);

  // implements Message ----------------------------------------------

  RequestOperationDescriptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestOperationDescriptions& from);
  void MergeFrom(const RequestOperationDescriptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // optional string odid = 2;
  inline bool has_odid() const;
  inline void clear_odid();
  static const int kOdidFieldNumber = 2;
  inline const ::std::string& odid() const;
  inline void set_odid(const ::std::string& value);
  inline void set_odid(const char* value);
  inline void set_odid(const char* value, size_t size);
  inline ::std::string* mutable_odid();
  inline ::std::string* release_odid();
  inline void set_allocated_odid(::std::string* odid);

  // optional string pdid = 3;
  inline bool has_pdid() const;
  inline void clear_pdid();
  static const int kPdidFieldNumber = 3;
  inline const ::std::string& pdid() const;
  inline void set_pdid(const ::std::string& value);
  inline void set_pdid(const char* value);
  inline void set_pdid(const char* value, size_t size);
  inline ::std::string* mutable_pdid();
  inline ::std::string* release_pdid();
  inline void set_allocated_pdid(::std::string* pdid);

  // optional string registerid = 4;
  inline bool has_registerid() const;
  inline void clear_registerid();
  static const int kRegisteridFieldNumber = 4;
  inline const ::std::string& registerid() const;
  inline void set_registerid(const ::std::string& value);
  inline void set_registerid(const char* value);
  inline void set_registerid(const char* value, size_t size);
  inline ::std::string* mutable_registerid();
  inline ::std::string* release_registerid();
  inline void set_allocated_registerid(::std::string* registerid);

  // @@protoc_insertion_point(class_scope:das.proto.RequestOperationDescriptions)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_odid();
  inline void clear_has_odid();
  inline void set_has_pdid();
  inline void clear_has_pdid();
  inline void set_has_registerid();
  inline void clear_has_registerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* odid_;
  ::std::string* pdid_;
  ::std::string* registerid_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestOperationDescriptions* default_instance_;
};
// -------------------------------------------------------------------

class AckRequestOperationDescriptions : public ::google::protobuf::Message {
 public:
  AckRequestOperationDescriptions();
  virtual ~AckRequestOperationDescriptions();

  AckRequestOperationDescriptions(const AckRequestOperationDescriptions& from);

  inline AckRequestOperationDescriptions& operator=(const AckRequestOperationDescriptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRequestOperationDescriptions& default_instance();

  void Swap(AckRequestOperationDescriptions* other);

  // implements Message ----------------------------------------------

  AckRequestOperationDescriptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRequestOperationDescriptions& from);
  void MergeFrom(const AckRequestOperationDescriptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .das.proto.OperationDescription ods = 3;
  inline int ods_size() const;
  inline void clear_ods();
  static const int kOdsFieldNumber = 3;
  inline const ::das::proto::OperationDescription& ods(int index) const;
  inline ::das::proto::OperationDescription* mutable_ods(int index);
  inline ::das::proto::OperationDescription* add_ods();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::OperationDescription >&
      ods() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::OperationDescription >*
      mutable_ods();

  // @@protoc_insertion_point(class_scope:das.proto.AckRequestOperationDescriptions)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::OperationDescription > ods_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckRequestOperationDescriptions* default_instance_;
};
// -------------------------------------------------------------------

class DeleteOperationDescription : public ::google::protobuf::Message {
 public:
  DeleteOperationDescription();
  virtual ~DeleteOperationDescription();

  DeleteOperationDescription(const DeleteOperationDescription& from);

  inline DeleteOperationDescription& operator=(const DeleteOperationDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteOperationDescription& default_instance();

  void Swap(DeleteOperationDescription* other);

  // implements Message ----------------------------------------------

  DeleteOperationDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteOperationDescription& from);
  void MergeFrom(const DeleteOperationDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string odid = 2;
  inline bool has_odid() const;
  inline void clear_odid();
  static const int kOdidFieldNumber = 2;
  inline const ::std::string& odid() const;
  inline void set_odid(const ::std::string& value);
  inline void set_odid(const char* value);
  inline void set_odid(const char* value, size_t size);
  inline ::std::string* mutable_odid();
  inline ::std::string* release_odid();
  inline void set_allocated_odid(::std::string* odid);

  // @@protoc_insertion_point(class_scope:das.proto.DeleteOperationDescription)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_odid();
  inline void clear_has_odid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* odid_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static DeleteOperationDescription* default_instance_;
};
// -------------------------------------------------------------------

class AckDeleteOperationDescription : public ::google::protobuf::Message {
 public:
  AckDeleteOperationDescription();
  virtual ~AckDeleteOperationDescription();

  AckDeleteOperationDescription(const AckDeleteOperationDescription& from);

  inline AckDeleteOperationDescription& operator=(const AckDeleteOperationDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckDeleteOperationDescription& default_instance();

  void Swap(AckDeleteOperationDescription* other);

  // implements Message ----------------------------------------------

  AckDeleteOperationDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckDeleteOperationDescription& from);
  void MergeFrom(const AckDeleteOperationDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckDeleteOperationDescription)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckDeleteOperationDescription* default_instance_;
};
// -------------------------------------------------------------------

class BillInformation : public ::google::protobuf::Message {
 public:
  BillInformation();
  virtual ~BillInformation();

  BillInformation(const BillInformation& from);

  inline BillInformation& operator=(const BillInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BillInformation& default_instance();

  void Swap(BillInformation* other);

  // implements Message ----------------------------------------------

  BillInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BillInformation& from);
  void MergeFrom(const BillInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float servicecharge = 1;
  inline bool has_servicecharge() const;
  inline void clear_servicecharge();
  static const int kServicechargeFieldNumber = 1;
  inline float servicecharge() const;
  inline void set_servicecharge(float value);

  // optional float pesticidecharge = 2;
  inline bool has_pesticidecharge() const;
  inline void clear_pesticidecharge();
  static const int kPesticidechargeFieldNumber = 2;
  inline float pesticidecharge() const;
  inline void set_pesticidecharge(float value);

  // optional float othercharge = 3;
  inline bool has_othercharge() const;
  inline void clear_othercharge();
  static const int kOtherchargeFieldNumber = 3;
  inline float othercharge() const;
  inline void set_othercharge(float value);

  // required float sumcharge = 4;
  inline bool has_sumcharge() const;
  inline void clear_sumcharge();
  static const int kSumchargeFieldNumber = 4;
  inline float sumcharge() const;
  inline void set_sumcharge(float value);

  // required string pesticide = 5;
  inline bool has_pesticide() const;
  inline void clear_pesticide();
  static const int kPesticideFieldNumber = 5;
  inline const ::std::string& pesticide() const;
  inline void set_pesticide(const ::std::string& value);
  inline void set_pesticide(const char* value);
  inline void set_pesticide(const char* value, size_t size);
  inline ::std::string* mutable_pesticide();
  inline ::std::string* release_pesticide();
  inline void set_allocated_pesticide(::std::string* pesticide);

  // required string crop = 6;
  inline bool has_crop() const;
  inline void clear_crop();
  static const int kCropFieldNumber = 6;
  inline const ::std::string& crop() const;
  inline void set_crop(const ::std::string& value);
  inline void set_crop(const char* value);
  inline void set_crop(const char* value, size_t size);
  inline ::std::string* mutable_crop();
  inline ::std::string* release_crop();
  inline void set_allocated_crop(::std::string* crop);

  // @@protoc_insertion_point(class_scope:das.proto.BillInformation)
 private:
  inline void set_has_servicecharge();
  inline void clear_has_servicecharge();
  inline void set_has_pesticidecharge();
  inline void clear_has_pesticidecharge();
  inline void set_has_othercharge();
  inline void clear_has_othercharge();
  inline void set_has_sumcharge();
  inline void clear_has_sumcharge();
  inline void set_has_pesticide();
  inline void clear_has_pesticide();
  inline void set_has_crop();
  inline void clear_has_crop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float servicecharge_;
  float pesticidecharge_;
  float othercharge_;
  float sumcharge_;
  ::std::string* pesticide_;
  ::std::string* crop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static BillInformation* default_instance_;
};
// -------------------------------------------------------------------

class OperationRoute : public ::google::protobuf::Message {
 public:
  OperationRoute();
  virtual ~OperationRoute();

  OperationRoute(const OperationRoute& from);

  inline OperationRoute& operator=(const OperationRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationRoute& default_instance();

  void Swap(OperationRoute* other);

  // implements Message ----------------------------------------------

  OperationRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationRoute& from);
  void MergeFrom(const OperationRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gsid = 1;
  inline bool has_gsid() const;
  inline void clear_gsid();
  static const int kGsidFieldNumber = 1;
  inline const ::std::string& gsid() const;
  inline void set_gsid(const ::std::string& value);
  inline void set_gsid(const char* value);
  inline void set_gsid(const char* value, size_t size);
  inline ::std::string* mutable_gsid();
  inline ::std::string* release_gsid();
  inline void set_allocated_gsid(::std::string* gsid);

  // required string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required string rpid = 3;
  inline bool has_rpid() const;
  inline void clear_rpid();
  static const int kRpidFieldNumber = 3;
  inline const ::std::string& rpid() const;
  inline void set_rpid(const ::std::string& value);
  inline void set_rpid(const char* value);
  inline void set_rpid(const char* value, size_t size);
  inline ::std::string* mutable_rpid();
  inline ::std::string* release_rpid();
  inline void set_allocated_rpid(::std::string* rpid);

  // required uint64 createtime = 4;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 4;
  inline ::google::protobuf::uint64 createtime() const;
  inline void set_createtime(::google::protobuf::uint64 value);

  // required float maxvoyage = 5;
  inline bool has_maxvoyage() const;
  inline void clear_maxvoyage();
  static const int kMaxvoyageFieldNumber = 5;
  inline float maxvoyage() const;
  inline void set_maxvoyage(float value);

  // repeated bytes missions = 6;
  inline int missions_size() const;
  inline void clear_missions();
  static const int kMissionsFieldNumber = 6;
  inline const ::std::string& missions(int index) const;
  inline ::std::string* mutable_missions(int index);
  inline void set_missions(int index, const ::std::string& value);
  inline void set_missions(int index, const char* value);
  inline void set_missions(int index, const void* value, size_t size);
  inline ::std::string* add_missions();
  inline void add_missions(const ::std::string& value);
  inline void add_missions(const char* value);
  inline void add_missions(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& missions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_missions();

  // repeated bytes boundarys = 7;
  inline int boundarys_size() const;
  inline void clear_boundarys();
  static const int kBoundarysFieldNumber = 7;
  inline const ::std::string& boundarys(int index) const;
  inline ::std::string* mutable_boundarys(int index);
  inline void set_boundarys(int index, const ::std::string& value);
  inline void set_boundarys(int index, const char* value);
  inline void set_boundarys(int index, const void* value, size_t size);
  inline ::std::string* add_boundarys();
  inline void add_boundarys(const ::std::string& value);
  inline void add_boundarys(const char* value);
  inline void add_boundarys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& boundarys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_boundarys();

  // optional .das.proto.BillInformation bi = 8;
  inline bool has_bi() const;
  inline void clear_bi();
  static const int kBiFieldNumber = 8;
  inline const ::das::proto::BillInformation& bi() const;
  inline ::das::proto::BillInformation* mutable_bi();
  inline ::das::proto::BillInformation* release_bi();
  inline void set_allocated_bi(::das::proto::BillInformation* bi);

  // @@protoc_insertion_point(class_scope:das.proto.OperationRoute)
 private:
  inline void set_has_gsid();
  inline void clear_has_gsid();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_rpid();
  inline void clear_has_rpid();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_maxvoyage();
  inline void clear_has_maxvoyage();
  inline void set_has_bi();
  inline void clear_has_bi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gsid_;
  ::std::string* uavid_;
  ::std::string* rpid_;
  ::google::protobuf::uint64 createtime_;
  ::google::protobuf::RepeatedPtrField< ::std::string> missions_;
  ::google::protobuf::RepeatedPtrField< ::std::string> boundarys_;
  ::das::proto::BillInformation* bi_;
  float maxvoyage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static OperationRoute* default_instance_;
};
// -------------------------------------------------------------------

class PostOperationRoute : public ::google::protobuf::Message {
 public:
  PostOperationRoute();
  virtual ~PostOperationRoute();

  PostOperationRoute(const PostOperationRoute& from);

  inline PostOperationRoute& operator=(const PostOperationRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostOperationRoute& default_instance();

  void Swap(PostOperationRoute* other);

  // implements Message ----------------------------------------------

  PostOperationRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostOperationRoute& from);
  void MergeFrom(const PostOperationRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required .das.proto.OperationRoute or = 2;
  inline bool has_or_() const;
  inline void clear_or_();
  static const int kOrFieldNumber = 2;
  inline const ::das::proto::OperationRoute& or_() const;
  inline ::das::proto::OperationRoute* mutable_or_();
  inline ::das::proto::OperationRoute* release_or_();
  inline void set_allocated_or_(::das::proto::OperationRoute* or_);

  // @@protoc_insertion_point(class_scope:das.proto.PostOperationRoute)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_or_();
  inline void clear_has_or_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::das::proto::OperationRoute* or__;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostOperationRoute* default_instance_;
};
// -------------------------------------------------------------------

class AckPostOperationRoute : public ::google::protobuf::Message {
 public:
  AckPostOperationRoute();
  virtual ~AckPostOperationRoute();

  AckPostOperationRoute(const AckPostOperationRoute& from);

  inline AckPostOperationRoute& operator=(const AckPostOperationRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostOperationRoute& default_instance();

  void Swap(AckPostOperationRoute* other);

  // implements Message ----------------------------------------------

  AckPostOperationRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostOperationRoute& from);
  void MergeFrom(const AckPostOperationRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostOperationRoute)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostOperationRoute* default_instance_;
};
// -------------------------------------------------------------------

class UploadOperationRoutes : public ::google::protobuf::Message {
 public:
  UploadOperationRoutes();
  virtual ~UploadOperationRoutes();

  UploadOperationRoutes(const UploadOperationRoutes& from);

  inline UploadOperationRoutes& operator=(const UploadOperationRoutes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadOperationRoutes& default_instance();

  void Swap(UploadOperationRoutes* other);

  // implements Message ----------------------------------------------

  UploadOperationRoutes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadOperationRoutes& from);
  void MergeFrom(const UploadOperationRoutes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required string userid = 3;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 3;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required uint64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required int32 countmission = 5;
  inline bool has_countmission() const;
  inline void clear_countmission();
  static const int kCountmissionFieldNumber = 5;
  inline ::google::protobuf::int32 countmission() const;
  inline void set_countmission(::google::protobuf::int32 value);

  // required int32 countboundary = 6;
  inline bool has_countboundary() const;
  inline void clear_countboundary();
  static const int kCountboundaryFieldNumber = 6;
  inline ::google::protobuf::int32 countboundary() const;
  inline void set_countboundary(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.UploadOperationRoutes)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_countmission();
  inline void clear_has_countmission();
  inline void set_has_countboundary();
  inline void clear_has_countboundary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::std::string* userid_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 countmission_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 countboundary_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static UploadOperationRoutes* default_instance_;
};
// -------------------------------------------------------------------

class SyscOperationRoutes : public ::google::protobuf::Message {
 public:
  SyscOperationRoutes();
  virtual ~SyscOperationRoutes();

  SyscOperationRoutes(const SyscOperationRoutes& from);

  inline SyscOperationRoutes& operator=(const SyscOperationRoutes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyscOperationRoutes& default_instance();

  void Swap(SyscOperationRoutes* other);

  // implements Message ----------------------------------------------

  SyscOperationRoutes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyscOperationRoutes& from);
  void MergeFrom(const SyscOperationRoutes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string uavid = 3;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 3;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // optional int32 index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 count = 6;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 6;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.SyscOperationRoutes)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* uavid_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static SyscOperationRoutes* default_instance_;
};
// -------------------------------------------------------------------

class RequestRouteMissions : public ::google::protobuf::Message {
 public:
  RequestRouteMissions();
  virtual ~RequestRouteMissions();

  RequestRouteMissions(const RequestRouteMissions& from);

  inline RequestRouteMissions& operator=(const RequestRouteMissions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRouteMissions& default_instance();

  void Swap(RequestRouteMissions* other);

  // implements Message ----------------------------------------------

  RequestRouteMissions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRouteMissions& from);
  void MergeFrom(const RequestRouteMissions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required bool boundary = 3;
  inline bool has_boundary() const;
  inline void clear_boundary();
  static const int kBoundaryFieldNumber = 3;
  inline bool boundary() const;
  inline void set_boundary(bool value);

  // required int32 offset = 4;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // required int32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required uint64 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:das.proto.RequestRouteMissions)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_boundary();
  inline void clear_has_boundary();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::google::protobuf::uint32 seqno_;
  bool boundary_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::uint64 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestRouteMissions* default_instance_;
};
// -------------------------------------------------------------------

class AckRequestRouteMissions : public ::google::protobuf::Message {
 public:
  AckRequestRouteMissions();
  virtual ~AckRequestRouteMissions();

  AckRequestRouteMissions(const AckRequestRouteMissions& from);

  inline AckRequestRouteMissions& operator=(const AckRequestRouteMissions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRequestRouteMissions& default_instance();

  void Swap(AckRequestRouteMissions* other);

  // implements Message ----------------------------------------------

  AckRequestRouteMissions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRequestRouteMissions& from);
  void MergeFrom(const AckRequestRouteMissions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required bool boundary = 3;
  inline bool has_boundary() const;
  inline void clear_boundary();
  static const int kBoundaryFieldNumber = 3;
  inline bool boundary() const;
  inline void set_boundary(bool value);

  // required int32 offset = 4;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // repeated bytes missions = 5;
  inline int missions_size() const;
  inline void clear_missions();
  static const int kMissionsFieldNumber = 5;
  inline const ::std::string& missions(int index) const;
  inline ::std::string* mutable_missions(int index);
  inline void set_missions(int index, const ::std::string& value);
  inline void set_missions(int index, const char* value);
  inline void set_missions(int index, const void* value, size_t size);
  inline ::std::string* add_missions();
  inline void add_missions(const ::std::string& value);
  inline void add_missions(const char* value);
  inline void add_missions(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& missions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_missions();

  // @@protoc_insertion_point(class_scope:das.proto.AckRequestRouteMissions)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_boundary();
  inline void clear_has_boundary();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  bool boundary_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::RepeatedPtrField< ::std::string> missions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckRequestRouteMissions* default_instance_;
};
// -------------------------------------------------------------------

class UavStatus : public ::google::protobuf::Message {
 public:
  UavStatus();
  virtual ~UavStatus();

  UavStatus(const UavStatus& from);

  inline UavStatus& operator=(const UavStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UavStatus& default_instance();

  void Swap(UavStatus* other);

  // implements Message ----------------------------------------------

  UavStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UavStatus& from);
  void MergeFrom(const UavStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uavid = 1;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 1;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional bool online = 3;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 3;
  inline bool online() const;
  inline void set_online(bool value);

  // optional bool landed = 4;
  inline bool has_landed() const;
  inline void clear_landed();
  static const int kLandedFieldNumber = 4;
  inline bool landed() const;
  inline void set_landed(bool value);

  // optional uint64 deadline = 5;
  inline bool has_deadline() const;
  inline void clear_deadline();
  static const int kDeadlineFieldNumber = 5;
  inline ::google::protobuf::uint64 deadline() const;
  inline void set_deadline(::google::protobuf::uint64 value);

  // optional bool binded = 6;
  inline bool has_binded() const;
  inline void clear_binded();
  static const int kBindedFieldNumber = 6;
  inline bool binded() const;
  inline void set_binded(bool value);

  // optional string binder = 7;
  inline bool has_binder() const;
  inline void clear_binder();
  static const int kBinderFieldNumber = 7;
  inline const ::std::string& binder() const;
  inline void set_binder(const ::std::string& value);
  inline void set_binder(const char* value);
  inline void set_binder(const char* value, size_t size);
  inline ::std::string* mutable_binder();
  inline ::std::string* release_binder();
  inline void set_allocated_binder(::std::string* binder);

  // optional uint64 bindtime = 8;
  inline bool has_bindtime() const;
  inline void clear_bindtime();
  static const int kBindtimeFieldNumber = 8;
  inline ::google::protobuf::uint64 bindtime() const;
  inline void set_bindtime(::google::protobuf::uint64 value);

  // optional uint64 unbindtime = 9;
  inline bool has_unbindtime() const;
  inline void clear_unbindtime();
  static const int kUnbindtimeFieldNumber = 9;
  inline ::google::protobuf::uint64 unbindtime() const;
  inline void set_unbindtime(::google::protobuf::uint64 value);

  // optional .das.proto.GpsInformation pos = 10;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 10;
  inline const ::das::proto::GpsInformation& pos() const;
  inline ::das::proto::GpsInformation* mutable_pos();
  inline ::das::proto::GpsInformation* release_pos();
  inline void set_allocated_pos(::das::proto::GpsInformation* pos);

  // optional uint64 timestamp = 11;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 11;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:das.proto.UavStatus)
 private:
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_landed();
  inline void clear_has_landed();
  inline void set_has_deadline();
  inline void clear_has_deadline();
  inline void set_has_binded();
  inline void clear_has_binded();
  inline void set_has_binder();
  inline void clear_has_binder();
  inline void set_has_bindtime();
  inline void clear_has_bindtime();
  inline void set_has_unbindtime();
  inline void clear_has_unbindtime();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::google::protobuf::int32 result_;
  bool online_;
  bool landed_;
  bool binded_;
  ::google::protobuf::uint64 deadline_;
  ::std::string* binder_;
  ::google::protobuf::uint64 bindtime_;
  ::google::protobuf::uint64 unbindtime_;
  ::das::proto::GpsInformation* pos_;
  ::google::protobuf::uint64 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static UavStatus* default_instance_;
};
// -------------------------------------------------------------------

class RequestUavStatus : public ::google::protobuf::Message {
 public:
  RequestUavStatus();
  virtual ~RequestUavStatus();

  RequestUavStatus(const RequestUavStatus& from);

  inline RequestUavStatus& operator=(const RequestUavStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUavStatus& default_instance();

  void Swap(RequestUavStatus* other);

  // implements Message ----------------------------------------------

  RequestUavStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUavStatus& from);
  void MergeFrom(const RequestUavStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // repeated string uavid = 2;
  inline int uavid_size() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid(int index) const;
  inline ::std::string* mutable_uavid(int index);
  inline void set_uavid(int index, const ::std::string& value);
  inline void set_uavid(int index, const char* value);
  inline void set_uavid(int index, const char* value, size_t size);
  inline ::std::string* add_uavid();
  inline void add_uavid(const ::std::string& value);
  inline void add_uavid(const char* value);
  inline void add_uavid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& uavid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_uavid();

  // @@protoc_insertion_point(class_scope:das.proto.RequestUavStatus)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> uavid_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestUavStatus* default_instance_;
};
// -------------------------------------------------------------------

class AckRequestUavStatus : public ::google::protobuf::Message {
 public:
  AckRequestUavStatus();
  virtual ~AckRequestUavStatus();

  AckRequestUavStatus(const AckRequestUavStatus& from);

  inline AckRequestUavStatus& operator=(const AckRequestUavStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRequestUavStatus& default_instance();

  void Swap(AckRequestUavStatus* other);

  // implements Message ----------------------------------------------

  AckRequestUavStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRequestUavStatus& from);
  void MergeFrom(const AckRequestUavStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // repeated .das.proto.UavStatus status = 2;
  inline int status_size() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::das::proto::UavStatus& status(int index) const;
  inline ::das::proto::UavStatus* mutable_status(int index);
  inline ::das::proto::UavStatus* add_status();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::UavStatus >&
      status() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::UavStatus >*
      mutable_status();

  // @@protoc_insertion_point(class_scope:das.proto.AckRequestUavStatus)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::das::proto::UavStatus > status_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckRequestUavStatus* default_instance_;
};
// -------------------------------------------------------------------

class RequestBindUav : public ::google::protobuf::Message {
 public:
  RequestBindUav();
  virtual ~RequestBindUav();

  RequestBindUav(const RequestBindUav& from);

  inline RequestBindUav& operator=(const RequestBindUav& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBindUav& default_instance();

  void Swap(RequestBindUav* other);

  // implements Message ----------------------------------------------

  RequestBindUav* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestBindUav& from);
  void MergeFrom(const RequestBindUav& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required uint32 opid = 2;
  inline bool has_opid() const;
  inline void clear_opid();
  static const int kOpidFieldNumber = 2;
  inline ::google::protobuf::uint32 opid() const;
  inline void set_opid(::google::protobuf::uint32 value);

  // required string uavid = 3;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 3;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required string binder = 4;
  inline bool has_binder() const;
  inline void clear_binder();
  static const int kBinderFieldNumber = 4;
  inline const ::std::string& binder() const;
  inline void set_binder(const ::std::string& value);
  inline void set_binder(const char* value);
  inline void set_binder(const char* value, size_t size);
  inline ::std::string* mutable_binder();
  inline ::std::string* release_binder();
  inline void set_allocated_binder(::std::string* binder);

  // @@protoc_insertion_point(class_scope:das.proto.RequestBindUav)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_opid();
  inline void clear_has_opid();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_binder();
  inline void clear_has_binder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 opid_;
  ::std::string* uavid_;
  ::std::string* binder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestBindUav* default_instance_;
};
// -------------------------------------------------------------------

class AckRequestBindUav : public ::google::protobuf::Message {
 public:
  AckRequestBindUav();
  virtual ~AckRequestBindUav();

  AckRequestBindUav(const AckRequestBindUav& from);

  inline AckRequestBindUav& operator=(const AckRequestBindUav& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRequestBindUav& default_instance();

  void Swap(AckRequestBindUav* other);

  // implements Message ----------------------------------------------

  AckRequestBindUav* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRequestBindUav& from);
  void MergeFrom(const AckRequestBindUav& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required uint32 opid = 2;
  inline bool has_opid() const;
  inline void clear_opid();
  static const int kOpidFieldNumber = 2;
  inline ::google::protobuf::uint32 opid() const;
  inline void set_opid(::google::protobuf::uint32 value);

  // required int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .das.proto.UavStatus status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::das::proto::UavStatus& status() const;
  inline ::das::proto::UavStatus* mutable_status();
  inline ::das::proto::UavStatus* release_status();
  inline void set_allocated_status(::das::proto::UavStatus* status);

  // @@protoc_insertion_point(class_scope:das.proto.AckRequestBindUav)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_opid();
  inline void clear_has_opid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 opid_;
  ::das::proto::UavStatus* status_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckRequestBindUav* default_instance_;
};
// -------------------------------------------------------------------

class UavProductInfo : public ::google::protobuf::Message {
 public:
  UavProductInfo();
  virtual ~UavProductInfo();

  UavProductInfo(const UavProductInfo& from);

  inline UavProductInfo& operator=(const UavProductInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UavProductInfo& default_instance();

  void Swap(UavProductInfo* other);

  // implements Message ----------------------------------------------

  UavProductInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UavProductInfo& from);
  void MergeFrom(const UavProductInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uavid = 1;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 1;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // optional string producttype = 2;
  inline bool has_producttype() const;
  inline void clear_producttype();
  static const int kProducttypeFieldNumber = 2;
  inline const ::std::string& producttype() const;
  inline void set_producttype(const ::std::string& value);
  inline void set_producttype(const char* value);
  inline void set_producttype(const char* value, size_t size);
  inline ::std::string* mutable_producttype();
  inline ::std::string* release_producttype();
  inline void set_allocated_producttype(::std::string* producttype);

  // optional string productid = 3;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductidFieldNumber = 3;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // optional string organization = 4;
  inline bool has_organization() const;
  inline void clear_organization();
  static const int kOrganizationFieldNumber = 4;
  inline const ::std::string& organization() const;
  inline void set_organization(const ::std::string& value);
  inline void set_organization(const char* value);
  inline void set_organization(const char* value, size_t size);
  inline ::std::string* mutable_organization();
  inline ::std::string* release_organization();
  inline void set_allocated_organization(::std::string* organization);

  // optional string manager = 5;
  inline bool has_manager() const;
  inline void clear_manager();
  static const int kManagerFieldNumber = 5;
  inline const ::std::string& manager() const;
  inline void set_manager(const ::std::string& value);
  inline void set_manager(const char* value);
  inline void set_manager(const char* value, size_t size);
  inline ::std::string* mutable_manager();
  inline ::std::string* release_manager();
  inline void set_allocated_manager(::std::string* manager);

  // optional string contact = 6;
  inline bool has_contact() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 6;
  inline const ::std::string& contact() const;
  inline void set_contact(const ::std::string& value);
  inline void set_contact(const char* value);
  inline void set_contact(const char* value, size_t size);
  inline ::std::string* mutable_contact();
  inline ::std::string* release_contact();
  inline void set_allocated_contact(::std::string* contact);

  // @@protoc_insertion_point(class_scope:das.proto.UavProductInfo)
 private:
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_producttype();
  inline void clear_has_producttype();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_organization();
  inline void clear_has_organization();
  inline void set_has_manager();
  inline void clear_has_manager();
  inline void set_has_contact();
  inline void clear_has_contact();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::std::string* producttype_;
  ::std::string* productid_;
  ::std::string* organization_;
  ::std::string* manager_;
  ::std::string* contact_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static UavProductInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestUavProductInfos : public ::google::protobuf::Message {
 public:
  RequestUavProductInfos();
  virtual ~RequestUavProductInfos();

  RequestUavProductInfos(const RequestUavProductInfos& from);

  inline RequestUavProductInfos& operator=(const RequestUavProductInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUavProductInfos& default_instance();

  void Swap(RequestUavProductInfos* other);

  // implements Message ----------------------------------------------

  RequestUavProductInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUavProductInfos& from);
  void MergeFrom(const RequestUavProductInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // repeated string productid = 2;
  inline int productid_size() const;
  inline void clear_productid();
  static const int kProductidFieldNumber = 2;
  inline const ::std::string& productid(int index) const;
  inline ::std::string* mutable_productid(int index);
  inline void set_productid(int index, const ::std::string& value);
  inline void set_productid(int index, const char* value);
  inline void set_productid(int index, const char* value, size_t size);
  inline ::std::string* add_productid();
  inline void add_productid(const ::std::string& value);
  inline void add_productid(const char* value);
  inline void add_productid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& productid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productid();

  // repeated string uavid = 3;
  inline int uavid_size() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 3;
  inline const ::std::string& uavid(int index) const;
  inline ::std::string* mutable_uavid(int index);
  inline void set_uavid(int index, const ::std::string& value);
  inline void set_uavid(int index, const char* value);
  inline void set_uavid(int index, const char* value, size_t size);
  inline ::std::string* add_uavid();
  inline void add_uavid(const ::std::string& value);
  inline void add_uavid(const char* value);
  inline void add_uavid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& uavid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_uavid();

  // @@protoc_insertion_point(class_scope:das.proto.RequestUavProductInfos)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> productid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> uavid_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static RequestUavProductInfos* default_instance_;
};
// -------------------------------------------------------------------

class AckRequestUavProductInfos : public ::google::protobuf::Message {
 public:
  AckRequestUavProductInfos();
  virtual ~AckRequestUavProductInfos();

  AckRequestUavProductInfos(const AckRequestUavProductInfos& from);

  inline AckRequestUavProductInfos& operator=(const AckRequestUavProductInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRequestUavProductInfos& default_instance();

  void Swap(AckRequestUavProductInfos* other);

  // implements Message ----------------------------------------------

  AckRequestUavProductInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRequestUavProductInfos& from);
  void MergeFrom(const AckRequestUavProductInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .das.proto.UavProductInfo upi = 3;
  inline int upi_size() const;
  inline void clear_upi();
  static const int kUpiFieldNumber = 3;
  inline const ::das::proto::UavProductInfo& upi(int index) const;
  inline ::das::proto::UavProductInfo* mutable_upi(int index);
  inline ::das::proto::UavProductInfo* add_upi();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo >&
      upi() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo >*
      mutable_upi();

  // @@protoc_insertion_point(class_scope:das.proto.AckRequestUavProductInfos)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo > upi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckRequestUavProductInfos* default_instance_;
};
// -------------------------------------------------------------------

class PostUavProductInfos : public ::google::protobuf::Message {
 public:
  PostUavProductInfos();
  virtual ~PostUavProductInfos();

  PostUavProductInfos(const PostUavProductInfos& from);

  inline PostUavProductInfos& operator=(const PostUavProductInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostUavProductInfos& default_instance();

  void Swap(PostUavProductInfos* other);

  // implements Message ----------------------------------------------

  PostUavProductInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostUavProductInfos& from);
  void MergeFrom(const PostUavProductInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // repeated .das.proto.UavProductInfo upi = 2;
  inline int upi_size() const;
  inline void clear_upi();
  static const int kUpiFieldNumber = 2;
  inline const ::das::proto::UavProductInfo& upi(int index) const;
  inline ::das::proto::UavProductInfo* mutable_upi(int index);
  inline ::das::proto::UavProductInfo* add_upi();
  inline const ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo >&
      upi() const;
  inline ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo >*
      mutable_upi();

  // @@protoc_insertion_point(class_scope:das.proto.PostUavProductInfos)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo > upi_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostUavProductInfos* default_instance_;
};
// -------------------------------------------------------------------

class AckPostUavProductInfos : public ::google::protobuf::Message {
 public:
  AckPostUavProductInfos();
  virtual ~AckPostUavProductInfos();

  AckPostUavProductInfos(const AckPostUavProductInfos& from);

  inline AckPostUavProductInfos& operator=(const AckPostUavProductInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostUavProductInfos& default_instance();

  void Swap(AckPostUavProductInfos* other);

  // implements Message ----------------------------------------------

  AckPostUavProductInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostUavProductInfos& from);
  void MergeFrom(const AckPostUavProductInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostUavProductInfos)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostUavProductInfos* default_instance_;
};
// -------------------------------------------------------------------

class PostControl2Uav : public ::google::protobuf::Message {
 public:
  PostControl2Uav();
  virtual ~PostControl2Uav();

  PostControl2Uav(const PostControl2Uav& from);

  inline PostControl2Uav& operator=(const PostControl2Uav& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostControl2Uav& default_instance();

  void Swap(PostControl2Uav* other);

  // implements Message ----------------------------------------------

  PostControl2Uav* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostControl2Uav& from);
  void MergeFrom(const PostControl2Uav& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required string userid = 3;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 3;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // repeated bytes data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data(int index) const;
  inline ::std::string* mutable_data(int index);
  inline void set_data(int index, const ::std::string& value);
  inline void set_data(int index, const char* value);
  inline void set_data(int index, const void* value, size_t size);
  inline ::std::string* add_data();
  inline void add_data(const ::std::string& value);
  inline void add_data(const char* value);
  inline void add_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // @@protoc_insertion_point(class_scope:das.proto.PostControl2Uav)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::std::string* userid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostControl2Uav* default_instance_;
};
// -------------------------------------------------------------------

class AckPostControl2Uav : public ::google::protobuf::Message {
 public:
  AckPostControl2Uav();
  virtual ~AckPostControl2Uav();

  AckPostControl2Uav(const AckPostControl2Uav& from);

  inline AckPostControl2Uav& operator=(const AckPostControl2Uav& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPostControl2Uav& default_instance();

  void Swap(AckPostControl2Uav* other);

  // implements Message ----------------------------------------------

  AckPostControl2Uav* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPostControl2Uav& from);
  void MergeFrom(const AckPostControl2Uav& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string uavid = 3;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 3;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // required string userid = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 4;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:das.proto.AckPostControl2Uav)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_uavid();
  inline void clear_has_uavid();
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::int32 result_;
  ::std::string* uavid_;
  ::std::string* userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static AckPostControl2Uav* default_instance_;
};
// -------------------------------------------------------------------

class PostStatus2GroundStation : public ::google::protobuf::Message {
 public:
  PostStatus2GroundStation();
  virtual ~PostStatus2GroundStation();

  PostStatus2GroundStation(const PostStatus2GroundStation& from);

  inline PostStatus2GroundStation& operator=(const PostStatus2GroundStation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostStatus2GroundStation& default_instance();

  void Swap(PostStatus2GroundStation* other);

  // implements Message ----------------------------------------------

  PostStatus2GroundStation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostStatus2GroundStation& from);
  void MergeFrom(const PostStatus2GroundStation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seqno = 1;
  inline bool has_seqno() const;
  inline void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  inline ::google::protobuf::uint32 seqno() const;
  inline void set_seqno(::google::protobuf::uint32 value);

  // required string uavid = 2;
  inline bool has_uavid() const;
  inline void clear_uavid();
  static const int kUavidFieldNumber = 2;
  inline const ::std::string& uavid() const;
  inline void set_uavid(const ::std::string& value);
  inline void set_uavid(const char* value);
  inline void set_uavid(const char* value, size_t size);
  inline ::std::string* mutable_uavid();
  inline ::std::string* release_uavid();
  inline void set_allocated_uavid(::std::string* uavid);

  // repeated bytes data = 3;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data(int index) const;
  inline ::std::string* mutable_data(int index);
  inline void set_data(int index, const ::std::string& value);
  inline void set_data(int index, const char* value);
  inline void set_data(int index, const void* value, size_t size);
  inline ::std::string* add_data();
  inline void add_data(const ::std::string& value);
  inline void add_data(const char* value);
  inline void add_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // @@protoc_insertion_point(class_scope:das.proto.PostStatus2GroundStation)
 private:
  inline void set_has_seqno();
  inline void clear_has_seqno();
  inline void set_has_uavid();
  inline void clear_has_uavid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uavid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  ::google::protobuf::uint32 seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_das_2eproto();
  friend void protobuf_AssignDesc_das_2eproto();
  friend void protobuf_ShutdownFile_das_2eproto();

  void InitAsDefaultInstance();
  static PostStatus2GroundStation* default_instance_;
};
// ===================================================================


// ===================================================================

// PostHeartBeat

// required uint32 seqno = 1;
inline bool PostHeartBeat::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostHeartBeat::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostHeartBeat::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostHeartBeat::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostHeartBeat::seqno() const {
  return seqno_;
}
inline void PostHeartBeat::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional string id = 2;
inline bool PostHeartBeat::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostHeartBeat::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostHeartBeat::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostHeartBeat::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& PostHeartBeat::id() const {
  return *id_;
}
inline void PostHeartBeat::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PostHeartBeat::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PostHeartBeat::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostHeartBeat::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* PostHeartBeat::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostHeartBeat::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckHeartBeat

// required uint32 seqno = 1;
inline bool AckHeartBeat::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckHeartBeat::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckHeartBeat::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckHeartBeat::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckHeartBeat::seqno() const {
  return seqno_;
}
inline void AckHeartBeat::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// -------------------------------------------------------------------

// ParameterDescription

// required string name = 1;
inline bool ParameterDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParameterDescription::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParameterDescription::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParameterDescription::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ParameterDescription::name() const {
  return *name_;
}
inline void ParameterDescription::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParameterDescription::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParameterDescription::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParameterDescription::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ParameterDescription::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParameterDescription::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool readonly = 2;
inline bool ParameterDescription::has_readonly() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParameterDescription::set_has_readonly() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParameterDescription::clear_has_readonly() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParameterDescription::clear_readonly() {
  readonly_ = false;
  clear_has_readonly();
}
inline bool ParameterDescription::readonly() const {
  return readonly_;
}
inline void ParameterDescription::set_readonly(bool value) {
  set_has_readonly();
  readonly_ = value;
}

// required uint32 type = 3;
inline bool ParameterDescription::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParameterDescription::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParameterDescription::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParameterDescription::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ParameterDescription::type() const {
  return type_;
}
inline void ParameterDescription::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required string value = 4;
inline bool ParameterDescription::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParameterDescription::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParameterDescription::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParameterDescription::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ParameterDescription::value() const {
  return *value_;
}
inline void ParameterDescription::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ParameterDescription::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ParameterDescription::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParameterDescription::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ParameterDescription::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParameterDescription::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryParameters

// required uint32 seqno = 1;
inline bool QueryParameters::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryParameters::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryParameters::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryParameters::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 QueryParameters::seqno() const {
  return seqno_;
}
inline void QueryParameters::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string id = 2;
inline bool QueryParameters::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryParameters::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryParameters::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryParameters::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& QueryParameters::id() const {
  return *id_;
}
inline void QueryParameters::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QueryParameters::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void QueryParameters::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryParameters::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* QueryParameters::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryParameters::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string pdnames = 3;
inline int QueryParameters::pdnames_size() const {
  return pdnames_.size();
}
inline void QueryParameters::clear_pdnames() {
  pdnames_.Clear();
}
inline const ::std::string& QueryParameters::pdnames(int index) const {
  return pdnames_.Get(index);
}
inline ::std::string* QueryParameters::mutable_pdnames(int index) {
  return pdnames_.Mutable(index);
}
inline void QueryParameters::set_pdnames(int index, const ::std::string& value) {
  pdnames_.Mutable(index)->assign(value);
}
inline void QueryParameters::set_pdnames(int index, const char* value) {
  pdnames_.Mutable(index)->assign(value);
}
inline void QueryParameters::set_pdnames(int index, const char* value, size_t size) {
  pdnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryParameters::add_pdnames() {
  return pdnames_.Add();
}
inline void QueryParameters::add_pdnames(const ::std::string& value) {
  pdnames_.Add()->assign(value);
}
inline void QueryParameters::add_pdnames(const char* value) {
  pdnames_.Add()->assign(value);
}
inline void QueryParameters::add_pdnames(const char* value, size_t size) {
  pdnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
QueryParameters::pdnames() const {
  return pdnames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
QueryParameters::mutable_pdnames() {
  return &pdnames_;
}

// -------------------------------------------------------------------

// AckQueryParameters

// required uint32 seqno = 1;
inline bool AckQueryParameters::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckQueryParameters::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckQueryParameters::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckQueryParameters::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckQueryParameters::seqno() const {
  return seqno_;
}
inline void AckQueryParameters::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string id = 2;
inline bool AckQueryParameters::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckQueryParameters::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckQueryParameters::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckQueryParameters::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AckQueryParameters::id() const {
  return *id_;
}
inline void AckQueryParameters::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckQueryParameters::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckQueryParameters::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckQueryParameters::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* AckQueryParameters::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckQueryParameters::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 result = 3;
inline bool AckQueryParameters::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckQueryParameters::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckQueryParameters::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckQueryParameters::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckQueryParameters::result() const {
  return result_;
}
inline void AckQueryParameters::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated .das.proto.ParameterDescription pd = 4;
inline int AckQueryParameters::pd_size() const {
  return pd_.size();
}
inline void AckQueryParameters::clear_pd() {
  pd_.Clear();
}
inline const ::das::proto::ParameterDescription& AckQueryParameters::pd(int index) const {
  return pd_.Get(index);
}
inline ::das::proto::ParameterDescription* AckQueryParameters::mutable_pd(int index) {
  return pd_.Mutable(index);
}
inline ::das::proto::ParameterDescription* AckQueryParameters::add_pd() {
  return pd_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >&
AckQueryParameters::pd() const {
  return pd_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >*
AckQueryParameters::mutable_pd() {
  return &pd_;
}

// -------------------------------------------------------------------

// ConfigureParameters

// required uint32 seqno = 1;
inline bool ConfigureParameters::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigureParameters::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigureParameters::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigureParameters::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 ConfigureParameters::seqno() const {
  return seqno_;
}
inline void ConfigureParameters::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string id = 2;
inline bool ConfigureParameters::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigureParameters::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigureParameters::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigureParameters::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ConfigureParameters::id() const {
  return *id_;
}
inline void ConfigureParameters::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConfigureParameters::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ConfigureParameters::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigureParameters::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ConfigureParameters::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigureParameters::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .das.proto.ParameterDescription pd = 3;
inline int ConfigureParameters::pd_size() const {
  return pd_.size();
}
inline void ConfigureParameters::clear_pd() {
  pd_.Clear();
}
inline const ::das::proto::ParameterDescription& ConfigureParameters::pd(int index) const {
  return pd_.Get(index);
}
inline ::das::proto::ParameterDescription* ConfigureParameters::mutable_pd(int index) {
  return pd_.Mutable(index);
}
inline ::das::proto::ParameterDescription* ConfigureParameters::add_pd() {
  return pd_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >&
ConfigureParameters::pd() const {
  return pd_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParameterDescription >*
ConfigureParameters::mutable_pd() {
  return &pd_;
}

// -------------------------------------------------------------------

// AckConfigurParameters

// required uint32 seqno = 1;
inline bool AckConfigurParameters::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckConfigurParameters::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckConfigurParameters::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckConfigurParameters::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckConfigurParameters::seqno() const {
  return seqno_;
}
inline void AckConfigurParameters::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string id = 2;
inline bool AckConfigurParameters::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckConfigurParameters::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckConfigurParameters::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckConfigurParameters::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AckConfigurParameters::id() const {
  return *id_;
}
inline void AckConfigurParameters::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckConfigurParameters::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckConfigurParameters::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckConfigurParameters::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* AckConfigurParameters::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckConfigurParameters::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 result = 3;
inline bool AckConfigurParameters::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckConfigurParameters::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckConfigurParameters::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckConfigurParameters::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckConfigurParameters::result() const {
  return result_;
}
inline void AckConfigurParameters::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// UpdateDeviceList

// required uint32 seqno = 1;
inline bool UpdateDeviceList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDeviceList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDeviceList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDeviceList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 UpdateDeviceList::seqno() const {
  return seqno_;
}
inline void UpdateDeviceList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required uint32 operation = 2;
inline bool UpdateDeviceList::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateDeviceList::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateDeviceList::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateDeviceList::clear_operation() {
  operation_ = 0u;
  clear_has_operation();
}
inline ::google::protobuf::uint32 UpdateDeviceList::operation() const {
  return operation_;
}
inline void UpdateDeviceList::set_operation(::google::protobuf::uint32 value) {
  set_has_operation();
  operation_ = value;
}

// repeated string id = 3;
inline int UpdateDeviceList::id_size() const {
  return id_.size();
}
inline void UpdateDeviceList::clear_id() {
  id_.Clear();
}
inline const ::std::string& UpdateDeviceList::id(int index) const {
  return id_.Get(index);
}
inline ::std::string* UpdateDeviceList::mutable_id(int index) {
  return id_.Mutable(index);
}
inline void UpdateDeviceList::set_id(int index, const ::std::string& value) {
  id_.Mutable(index)->assign(value);
}
inline void UpdateDeviceList::set_id(int index, const char* value) {
  id_.Mutable(index)->assign(value);
}
inline void UpdateDeviceList::set_id(int index, const char* value, size_t size) {
  id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDeviceList::add_id() {
  return id_.Add();
}
inline void UpdateDeviceList::add_id(const ::std::string& value) {
  id_.Add()->assign(value);
}
inline void UpdateDeviceList::add_id(const char* value) {
  id_.Add()->assign(value);
}
inline void UpdateDeviceList::add_id(const char* value, size_t size) {
  id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UpdateDeviceList::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UpdateDeviceList::mutable_id() {
  return &id_;
}

// -------------------------------------------------------------------

// AckUpdateDeviceList

// required uint32 seqno = 1;
inline bool AckUpdateDeviceList::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpdateDeviceList::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpdateDeviceList::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpdateDeviceList::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckUpdateDeviceList::seqno() const {
  return seqno_;
}
inline void AckUpdateDeviceList::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckUpdateDeviceList::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpdateDeviceList::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpdateDeviceList::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpdateDeviceList::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckUpdateDeviceList::result() const {
  return result_;
}
inline void AckUpdateDeviceList::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestIdentityAllocation

// required uint32 seqno = 1;
inline bool RequestIdentityAllocation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestIdentityAllocation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestIdentityAllocation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestIdentityAllocation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestIdentityAllocation::seqno() const {
  return seqno_;
}
inline void RequestIdentityAllocation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string devtype = 2;
inline bool RequestIdentityAllocation::has_devtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestIdentityAllocation::set_has_devtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestIdentityAllocation::clear_has_devtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestIdentityAllocation::clear_devtype() {
  if (devtype_ != &::google::protobuf::internal::kEmptyString) {
    devtype_->clear();
  }
  clear_has_devtype();
}
inline const ::std::string& RequestIdentityAllocation::devtype() const {
  return *devtype_;
}
inline void RequestIdentityAllocation::set_devtype(const ::std::string& value) {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  devtype_->assign(value);
}
inline void RequestIdentityAllocation::set_devtype(const char* value) {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  devtype_->assign(value);
}
inline void RequestIdentityAllocation::set_devtype(const char* value, size_t size) {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  devtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestIdentityAllocation::mutable_devtype() {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  return devtype_;
}
inline ::std::string* RequestIdentityAllocation::release_devtype() {
  clear_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devtype_;
    devtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestIdentityAllocation::set_allocated_devtype(::std::string* devtype) {
  if (devtype_ != &::google::protobuf::internal::kEmptyString) {
    delete devtype_;
  }
  if (devtype) {
    set_has_devtype();
    devtype_ = devtype;
  } else {
    clear_has_devtype();
    devtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 3;
inline bool RequestIdentityAllocation::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestIdentityAllocation::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestIdentityAllocation::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestIdentityAllocation::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& RequestIdentityAllocation::extradata() const {
  return *extradata_;
}
inline void RequestIdentityAllocation::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestIdentityAllocation::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestIdentityAllocation::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestIdentityAllocation::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* RequestIdentityAllocation::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestIdentityAllocation::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckIdentityAllocation

// required uint32 seqno = 1;
inline bool AckIdentityAllocation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckIdentityAllocation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckIdentityAllocation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckIdentityAllocation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckIdentityAllocation::seqno() const {
  return seqno_;
}
inline void AckIdentityAllocation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckIdentityAllocation::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckIdentityAllocation::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckIdentityAllocation::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckIdentityAllocation::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckIdentityAllocation::result() const {
  return result_;
}
inline void AckIdentityAllocation::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string id = 3;
inline bool AckIdentityAllocation::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckIdentityAllocation::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckIdentityAllocation::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckIdentityAllocation::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AckIdentityAllocation::id() const {
  return *id_;
}
inline void AckIdentityAllocation::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckIdentityAllocation::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AckIdentityAllocation::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckIdentityAllocation::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* AckIdentityAllocation::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckIdentityAllocation::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 4;
inline bool AckIdentityAllocation::has_extradata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckIdentityAllocation::set_has_extradata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckIdentityAllocation::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckIdentityAllocation::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& AckIdentityAllocation::extradata() const {
  return *extradata_;
}
inline void AckIdentityAllocation::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckIdentityAllocation::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckIdentityAllocation::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckIdentityAllocation::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* AckIdentityAllocation::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckIdentityAllocation::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostProgram

// required uint32 seqno = 1;
inline bool PostProgram::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostProgram::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostProgram::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostProgram::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostProgram::seqno() const {
  return seqno_;
}
inline void PostProgram::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string name = 2;
inline bool PostProgram::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostProgram::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostProgram::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostProgram::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PostProgram::name() const {
  return *name_;
}
inline void PostProgram::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PostProgram::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PostProgram::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostProgram::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PostProgram::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostProgram::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 offset = 3;
inline bool PostProgram::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostProgram::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostProgram::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostProgram::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 PostProgram::offset() const {
  return offset_;
}
inline void PostProgram::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional bytes data = 4;
inline bool PostProgram::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PostProgram::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PostProgram::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PostProgram::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PostProgram::data() const {
  return *data_;
}
inline void PostProgram::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PostProgram::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PostProgram::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostProgram::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* PostProgram::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostProgram::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fwtype = 5;
inline bool PostProgram::has_fwtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PostProgram::set_has_fwtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PostProgram::clear_has_fwtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PostProgram::clear_fwtype() {
  fwtype_ = 0;
  clear_has_fwtype();
}
inline ::google::protobuf::int32 PostProgram::fwtype() const {
  return fwtype_;
}
inline void PostProgram::set_fwtype(::google::protobuf::int32 value) {
  set_has_fwtype();
  fwtype_ = value;
}

// optional int32 length = 6;
inline bool PostProgram::has_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PostProgram::set_has_length() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PostProgram::clear_has_length() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PostProgram::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 PostProgram::length() const {
  return length_;
}
inline void PostProgram::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// optional uint32 crc32 = 7;
inline bool PostProgram::has_crc32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PostProgram::set_has_crc32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PostProgram::clear_has_crc32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PostProgram::clear_crc32() {
  crc32_ = 0u;
  clear_has_crc32();
}
inline ::google::protobuf::uint32 PostProgram::crc32() const {
  return crc32_;
}
inline void PostProgram::set_crc32(::google::protobuf::uint32 value) {
  set_has_crc32();
  crc32_ = value;
}

// optional bool release = 8;
inline bool PostProgram::has_release() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PostProgram::set_has_release() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PostProgram::clear_has_release() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PostProgram::clear_release() {
  release_ = false;
  clear_has_release();
}
inline bool PostProgram::release() const {
  return release_;
}
inline void PostProgram::set_release(bool value) {
  set_has_release();
  release_ = value;
}

// -------------------------------------------------------------------

// AckPostProgram

// required uint32 seqno = 1;
inline bool AckPostProgram::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostProgram::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostProgram::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostProgram::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostProgram::seqno() const {
  return seqno_;
}
inline void AckPostProgram::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPostProgram::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostProgram::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostProgram::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostProgram::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPostProgram::result() const {
  return result_;
}
inline void AckPostProgram::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// NotifyProgram

// required uint32 seqno = 1;
inline bool NotifyProgram::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyProgram::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyProgram::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyProgram::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 NotifyProgram::seqno() const {
  return seqno_;
}
inline void NotifyProgram::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string uavid = 2;
inline bool NotifyProgram::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyProgram::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyProgram::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyProgram::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& NotifyProgram::uavid() const {
  return *uavid_;
}
inline void NotifyProgram::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void NotifyProgram::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void NotifyProgram::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyProgram::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* NotifyProgram::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyProgram::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool NotifyProgram::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyProgram::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyProgram::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyProgram::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NotifyProgram::name() const {
  return *name_;
}
inline void NotifyProgram::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NotifyProgram::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NotifyProgram::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyProgram::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NotifyProgram::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyProgram::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 fwtype = 4;
inline bool NotifyProgram::has_fwtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NotifyProgram::set_has_fwtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NotifyProgram::clear_has_fwtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NotifyProgram::clear_fwtype() {
  fwtype_ = 0;
  clear_has_fwtype();
}
inline ::google::protobuf::int32 NotifyProgram::fwtype() const {
  return fwtype_;
}
inline void NotifyProgram::set_fwtype(::google::protobuf::int32 value) {
  set_has_fwtype();
  fwtype_ = value;
}

// required int32 length = 5;
inline bool NotifyProgram::has_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NotifyProgram::set_has_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NotifyProgram::clear_has_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NotifyProgram::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 NotifyProgram::length() const {
  return length_;
}
inline void NotifyProgram::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// required uint32 crc32 = 6;
inline bool NotifyProgram::has_crc32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NotifyProgram::set_has_crc32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NotifyProgram::clear_has_crc32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NotifyProgram::clear_crc32() {
  crc32_ = 0u;
  clear_has_crc32();
}
inline ::google::protobuf::uint32 NotifyProgram::crc32() const {
  return crc32_;
}
inline void NotifyProgram::set_crc32(::google::protobuf::uint32 value) {
  set_has_crc32();
  crc32_ = value;
}

// -------------------------------------------------------------------

// AckNotifyProgram

// required uint32 seqno = 1;
inline bool AckNotifyProgram::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckNotifyProgram::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckNotifyProgram::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckNotifyProgram::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckNotifyProgram::seqno() const {
  return seqno_;
}
inline void AckNotifyProgram::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckNotifyProgram::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckNotifyProgram::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckNotifyProgram::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckNotifyProgram::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckNotifyProgram::result() const {
  return result_;
}
inline void AckNotifyProgram::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestProgram

// required uint32 seqno = 1;
inline bool RequestProgram::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestProgram::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestProgram::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestProgram::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestProgram::seqno() const {
  return seqno_;
}
inline void RequestProgram::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string name = 2;
inline bool RequestProgram::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestProgram::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestProgram::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestProgram::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RequestProgram::name() const {
  return *name_;
}
inline void RequestProgram::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestProgram::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestProgram::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestProgram::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RequestProgram::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestProgram::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 offset = 3;
inline bool RequestProgram::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestProgram::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestProgram::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestProgram::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 RequestProgram::offset() const {
  return offset_;
}
inline void RequestProgram::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// required int32 length = 4;
inline bool RequestProgram::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestProgram::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestProgram::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestProgram::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 RequestProgram::length() const {
  return length_;
}
inline void RequestProgram::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// AckRequestProgram

// required uint32 seqno = 1;
inline bool AckRequestProgram::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRequestProgram::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRequestProgram::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRequestProgram::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckRequestProgram::seqno() const {
  return seqno_;
}
inline void AckRequestProgram::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckRequestProgram::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRequestProgram::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRequestProgram::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRequestProgram::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckRequestProgram::result() const {
  return result_;
}
inline void AckRequestProgram::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string name = 3;
inline bool AckRequestProgram::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckRequestProgram::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckRequestProgram::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckRequestProgram::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AckRequestProgram::name() const {
  return *name_;
}
inline void AckRequestProgram::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckRequestProgram::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckRequestProgram::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckRequestProgram::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AckRequestProgram::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckRequestProgram::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 offset = 4;
inline bool AckRequestProgram::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckRequestProgram::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckRequestProgram::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckRequestProgram::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 AckRequestProgram::offset() const {
  return offset_;
}
inline void AckRequestProgram::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional bytes data = 5;
inline bool AckRequestProgram::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckRequestProgram::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckRequestProgram::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckRequestProgram::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& AckRequestProgram::data() const {
  return *data_;
}
inline void AckRequestProgram::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AckRequestProgram::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AckRequestProgram::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckRequestProgram::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* AckRequestProgram::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckRequestProgram::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestPositionAuthentication

// required uint32 seqno = 1;
inline bool RequestPositionAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPositionAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPositionAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPositionAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestPositionAuthentication::seqno() const {
  return seqno_;
}
inline void RequestPositionAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string devid = 2;
inline bool RequestPositionAuthentication::has_devid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPositionAuthentication::set_has_devid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPositionAuthentication::clear_has_devid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPositionAuthentication::clear_devid() {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    devid_->clear();
  }
  clear_has_devid();
}
inline const ::std::string& RequestPositionAuthentication::devid() const {
  return *devid_;
}
inline void RequestPositionAuthentication::set_devid(const ::std::string& value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void RequestPositionAuthentication::set_devid(const char* value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void RequestPositionAuthentication::set_devid(const char* value, size_t size) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestPositionAuthentication::mutable_devid() {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  return devid_;
}
inline ::std::string* RequestPositionAuthentication::release_devid() {
  clear_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devid_;
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestPositionAuthentication::set_allocated_devid(::std::string* devid) {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    delete devid_;
  }
  if (devid) {
    set_has_devid();
    devid_ = devid;
  } else {
    clear_has_devid();
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .das.proto.GpsInformation pos = 3;
inline bool RequestPositionAuthentication::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestPositionAuthentication::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestPositionAuthentication::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestPositionAuthentication::clear_pos() {
  if (pos_ != NULL) pos_->::das::proto::GpsInformation::Clear();
  clear_has_pos();
}
inline const ::das::proto::GpsInformation& RequestPositionAuthentication::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::das::proto::GpsInformation* RequestPositionAuthentication::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::das::proto::GpsInformation;
  return pos_;
}
inline ::das::proto::GpsInformation* RequestPositionAuthentication::release_pos() {
  clear_has_pos();
  ::das::proto::GpsInformation* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void RequestPositionAuthentication::set_allocated_pos(::das::proto::GpsInformation* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// -------------------------------------------------------------------

// AckPositionAuthentication

// required uint32 seqno = 1;
inline bool AckPositionAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPositionAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPositionAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPositionAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPositionAuthentication::seqno() const {
  return seqno_;
}
inline void AckPositionAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPositionAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPositionAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPositionAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPositionAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPositionAuthentication::result() const {
  return result_;
}
inline void AckPositionAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string devid = 3;
inline bool AckPositionAuthentication::has_devid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckPositionAuthentication::set_has_devid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckPositionAuthentication::clear_has_devid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckPositionAuthentication::clear_devid() {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    devid_->clear();
  }
  clear_has_devid();
}
inline const ::std::string& AckPositionAuthentication::devid() const {
  return *devid_;
}
inline void AckPositionAuthentication::set_devid(const ::std::string& value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void AckPositionAuthentication::set_devid(const char* value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void AckPositionAuthentication::set_devid(const char* value, size_t size) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPositionAuthentication::mutable_devid() {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  return devid_;
}
inline ::std::string* AckPositionAuthentication::release_devid() {
  clear_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devid_;
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPositionAuthentication::set_allocated_devid(::std::string* devid) {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    delete devid_;
  }
  if (devid) {
    set_has_devid();
    devid_ = devid;
  } else {
    clear_has_devid();
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Request3rdIdentityAuthentication

// required uint32 seqno = 1;
inline bool Request3rdIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request3rdIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request3rdIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request3rdIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 Request3rdIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void Request3rdIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string identification = 2;
inline bool Request3rdIdentityAuthentication::has_identification() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request3rdIdentityAuthentication::set_has_identification() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request3rdIdentityAuthentication::clear_has_identification() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request3rdIdentityAuthentication::clear_identification() {
  if (identification_ != &::google::protobuf::internal::kEmptyString) {
    identification_->clear();
  }
  clear_has_identification();
}
inline const ::std::string& Request3rdIdentityAuthentication::identification() const {
  return *identification_;
}
inline void Request3rdIdentityAuthentication::set_identification(const ::std::string& value) {
  set_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    identification_ = new ::std::string;
  }
  identification_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_identification(const char* value) {
  set_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    identification_ = new ::std::string;
  }
  identification_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_identification(const char* value, size_t size) {
  set_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    identification_ = new ::std::string;
  }
  identification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request3rdIdentityAuthentication::mutable_identification() {
  set_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    identification_ = new ::std::string;
  }
  return identification_;
}
inline ::std::string* Request3rdIdentityAuthentication::release_identification() {
  clear_has_identification();
  if (identification_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identification_;
    identification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request3rdIdentityAuthentication::set_allocated_identification(::std::string* identification) {
  if (identification_ != &::google::protobuf::internal::kEmptyString) {
    delete identification_;
  }
  if (identification) {
    set_has_identification();
    identification_ = identification;
  } else {
    clear_has_identification();
    identification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string secretkey = 3;
inline bool Request3rdIdentityAuthentication::has_secretkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request3rdIdentityAuthentication::set_has_secretkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request3rdIdentityAuthentication::clear_has_secretkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request3rdIdentityAuthentication::clear_secretkey() {
  if (secretkey_ != &::google::protobuf::internal::kEmptyString) {
    secretkey_->clear();
  }
  clear_has_secretkey();
}
inline const ::std::string& Request3rdIdentityAuthentication::secretkey() const {
  return *secretkey_;
}
inline void Request3rdIdentityAuthentication::set_secretkey(const ::std::string& value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_secretkey(const char* value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_secretkey(const char* value, size_t size) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request3rdIdentityAuthentication::mutable_secretkey() {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  return secretkey_;
}
inline ::std::string* Request3rdIdentityAuthentication::release_secretkey() {
  clear_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secretkey_;
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request3rdIdentityAuthentication::set_allocated_secretkey(::std::string* secretkey) {
  if (secretkey_ != &::google::protobuf::internal::kEmptyString) {
    delete secretkey_;
  }
  if (secretkey) {
    set_has_secretkey();
    secretkey_ = secretkey;
  } else {
    clear_has_secretkey();
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 4;
inline bool Request3rdIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request3rdIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request3rdIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request3rdIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& Request3rdIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void Request3rdIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void Request3rdIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request3rdIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* Request3rdIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request3rdIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Ack3rdIdentityAuthentication

// required uint32 seqno = 1;
inline bool Ack3rdIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ack3rdIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ack3rdIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ack3rdIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 Ack3rdIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void Ack3rdIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool Ack3rdIdentityAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ack3rdIdentityAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ack3rdIdentityAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ack3rdIdentityAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 Ack3rdIdentityAuthentication::result() const {
  return result_;
}
inline void Ack3rdIdentityAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string extradata = 3;
inline bool Ack3rdIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ack3rdIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ack3rdIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ack3rdIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& Ack3rdIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void Ack3rdIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void Ack3rdIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void Ack3rdIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ack3rdIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* Ack3rdIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ack3rdIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestUavIdentityAuthentication

// required uint32 seqno = 1;
inline bool RequestUavIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUavIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUavIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUavIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestUavIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void RequestUavIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string uavid = 2;
inline bool RequestUavIdentityAuthentication::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUavIdentityAuthentication::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUavIdentityAuthentication::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUavIdentityAuthentication::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& RequestUavIdentityAuthentication::uavid() const {
  return *uavid_;
}
inline void RequestUavIdentityAuthentication::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void RequestUavIdentityAuthentication::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void RequestUavIdentityAuthentication::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUavIdentityAuthentication::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* RequestUavIdentityAuthentication::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestUavIdentityAuthentication::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extradata = 3;
inline bool RequestUavIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUavIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUavIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUavIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& RequestUavIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void RequestUavIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestUavIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void RequestUavIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUavIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* RequestUavIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestUavIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckUavIdentityAuthentication

// required uint32 seqno = 1;
inline bool AckUavIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUavIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUavIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckUavIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void AckUavIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional string uavid = 2;
inline bool AckUavIdentityAuthentication::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUavIdentityAuthentication::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUavIdentityAuthentication::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& AckUavIdentityAuthentication::uavid() const {
  return *uavid_;
}
inline void AckUavIdentityAuthentication::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void AckUavIdentityAuthentication::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void AckUavIdentityAuthentication::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckUavIdentityAuthentication::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* AckUavIdentityAuthentication::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckUavIdentityAuthentication::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 result = 3;
inline bool AckUavIdentityAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckUavIdentityAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckUavIdentityAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckUavIdentityAuthentication::result() const {
  return result_;
}
inline void AckUavIdentityAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional uint64 deadline = 4;
inline bool AckUavIdentityAuthentication::has_deadline() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_deadline() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckUavIdentityAuthentication::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckUavIdentityAuthentication::clear_deadline() {
  deadline_ = GOOGLE_ULONGLONG(0);
  clear_has_deadline();
}
inline ::google::protobuf::uint64 AckUavIdentityAuthentication::deadline() const {
  return deadline_;
}
inline void AckUavIdentityAuthentication::set_deadline(::google::protobuf::uint64 value) {
  set_has_deadline();
  deadline_ = value;
}

// optional string extradata = 5;
inline bool AckUavIdentityAuthentication::has_extradata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckUavIdentityAuthentication::set_has_extradata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckUavIdentityAuthentication::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckUavIdentityAuthentication::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& AckUavIdentityAuthentication::extradata() const {
  return *extradata_;
}
inline void AckUavIdentityAuthentication::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckUavIdentityAuthentication::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void AckUavIdentityAuthentication::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckUavIdentityAuthentication::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* AckUavIdentityAuthentication::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckUavIdentityAuthentication::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestNewGS

// required uint32 seqno = 1;
inline bool RequestNewGS::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNewGS::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNewGS::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNewGS::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestNewGS::seqno() const {
  return seqno_;
}
inline void RequestNewGS::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string userid = 2;
inline bool RequestNewGS::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNewGS::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNewGS::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNewGS::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& RequestNewGS::userid() const {
  return *userid_;
}
inline void RequestNewGS::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RequestNewGS::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RequestNewGS::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestNewGS::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* RequestNewGS::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestNewGS::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 3;
inline bool RequestNewGS::has_phone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestNewGS::set_has_phone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestNewGS::clear_has_phone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestNewGS::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& RequestNewGS::phone() const {
  return *phone_;
}
inline void RequestNewGS::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RequestNewGS::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RequestNewGS::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestNewGS::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* RequestNewGS::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestNewGS::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string check = 4;
inline bool RequestNewGS::has_check() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestNewGS::set_has_check() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestNewGS::clear_has_check() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestNewGS::clear_check() {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    check_->clear();
  }
  clear_has_check();
}
inline const ::std::string& RequestNewGS::check() const {
  return *check_;
}
inline void RequestNewGS::set_check(const ::std::string& value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void RequestNewGS::set_check(const char* value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void RequestNewGS::set_check(const char* value, size_t size) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestNewGS::mutable_check() {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  return check_;
}
inline ::std::string* RequestNewGS::release_check() {
  clear_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = check_;
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestNewGS::set_allocated_check(::std::string* check) {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    delete check_;
  }
  if (check) {
    set_has_check();
    check_ = check;
  } else {
    clear_has_check();
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 5;
inline bool RequestNewGS::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestNewGS::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestNewGS::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestNewGS::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RequestNewGS::password() const {
  return *password_;
}
inline void RequestNewGS::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestNewGS::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestNewGS::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestNewGS::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* RequestNewGS::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestNewGS::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckNewGS

// required uint32 seqno = 1;
inline bool AckNewGS::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckNewGS::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckNewGS::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckNewGS::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckNewGS::seqno() const {
  return seqno_;
}
inline void AckNewGS::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckNewGS::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckNewGS::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckNewGS::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckNewGS::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckNewGS::result() const {
  return result_;
}
inline void AckNewGS::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string check = 3;
inline bool AckNewGS::has_check() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckNewGS::set_has_check() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckNewGS::clear_has_check() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckNewGS::clear_check() {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    check_->clear();
  }
  clear_has_check();
}
inline const ::std::string& AckNewGS::check() const {
  return *check_;
}
inline void AckNewGS::set_check(const ::std::string& value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void AckNewGS::set_check(const char* value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void AckNewGS::set_check(const char* value, size_t size) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckNewGS::mutable_check() {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  return check_;
}
inline ::std::string* AckNewGS::release_check() {
  clear_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = check_;
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckNewGS::set_allocated_check(::std::string* check) {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    delete check_;
  }
  if (check) {
    set_has_check();
    check_ = check;
  } else {
    clear_has_check();
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestGSIdentityAuthentication

// required uint32 seqno = 1;
inline bool RequestGSIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGSIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGSIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGSIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestGSIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void RequestGSIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string userid = 2;
inline bool RequestGSIdentityAuthentication::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGSIdentityAuthentication::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGSIdentityAuthentication::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGSIdentityAuthentication::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& RequestGSIdentityAuthentication::userid() const {
  return *userid_;
}
inline void RequestGSIdentityAuthentication::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RequestGSIdentityAuthentication::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RequestGSIdentityAuthentication::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGSIdentityAuthentication::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* RequestGSIdentityAuthentication::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestGSIdentityAuthentication::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 3;
inline bool RequestGSIdentityAuthentication::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestGSIdentityAuthentication::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestGSIdentityAuthentication::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestGSIdentityAuthentication::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RequestGSIdentityAuthentication::password() const {
  return *password_;
}
inline void RequestGSIdentityAuthentication::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestGSIdentityAuthentication::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RequestGSIdentityAuthentication::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGSIdentityAuthentication::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* RequestGSIdentityAuthentication::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestGSIdentityAuthentication::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 4;
inline bool RequestGSIdentityAuthentication::has_phone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestGSIdentityAuthentication::set_has_phone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestGSIdentityAuthentication::clear_has_phone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestGSIdentityAuthentication::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& RequestGSIdentityAuthentication::phone() const {
  return *phone_;
}
inline void RequestGSIdentityAuthentication::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RequestGSIdentityAuthentication::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void RequestGSIdentityAuthentication::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGSIdentityAuthentication::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* RequestGSIdentityAuthentication::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestGSIdentityAuthentication::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string check = 5;
inline bool RequestGSIdentityAuthentication::has_check() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestGSIdentityAuthentication::set_has_check() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestGSIdentityAuthentication::clear_has_check() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestGSIdentityAuthentication::clear_check() {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    check_->clear();
  }
  clear_has_check();
}
inline const ::std::string& RequestGSIdentityAuthentication::check() const {
  return *check_;
}
inline void RequestGSIdentityAuthentication::set_check(const ::std::string& value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void RequestGSIdentityAuthentication::set_check(const char* value) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(value);
}
inline void RequestGSIdentityAuthentication::set_check(const char* value, size_t size) {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  check_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGSIdentityAuthentication::mutable_check() {
  set_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    check_ = new ::std::string;
  }
  return check_;
}
inline ::std::string* RequestGSIdentityAuthentication::release_check() {
  clear_has_check();
  if (check_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = check_;
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestGSIdentityAuthentication::set_allocated_check(::std::string* check) {
  if (check_ != &::google::protobuf::internal::kEmptyString) {
    delete check_;
  }
  if (check) {
    set_has_check();
    check_ = check;
  } else {
    clear_has_check();
    check_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckGSIdentityAuthentication

// required uint32 seqno = 1;
inline bool AckGSIdentityAuthentication::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGSIdentityAuthentication::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGSIdentityAuthentication::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGSIdentityAuthentication::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckGSIdentityAuthentication::seqno() const {
  return seqno_;
}
inline void AckGSIdentityAuthentication::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckGSIdentityAuthentication::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckGSIdentityAuthentication::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckGSIdentityAuthentication::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckGSIdentityAuthentication::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckGSIdentityAuthentication::result() const {
  return result_;
}
inline void AckGSIdentityAuthentication::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string password = 3;
inline bool AckGSIdentityAuthentication::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckGSIdentityAuthentication::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckGSIdentityAuthentication::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckGSIdentityAuthentication::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& AckGSIdentityAuthentication::password() const {
  return *password_;
}
inline void AckGSIdentityAuthentication::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AckGSIdentityAuthentication::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AckGSIdentityAuthentication::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGSIdentityAuthentication::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* AckGSIdentityAuthentication::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckGSIdentityAuthentication::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GpsInformation

// required int32 longitude = 1;
inline bool GpsInformation::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpsInformation::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpsInformation::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpsInformation::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline ::google::protobuf::int32 GpsInformation::longitude() const {
  return longitude_;
}
inline void GpsInformation::set_longitude(::google::protobuf::int32 value) {
  set_has_longitude();
  longitude_ = value;
}

// required int32 latitude = 2;
inline bool GpsInformation::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpsInformation::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpsInformation::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpsInformation::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline ::google::protobuf::int32 GpsInformation::latitude() const {
  return latitude_;
}
inline void GpsInformation::set_latitude(::google::protobuf::int32 value) {
  set_has_latitude();
  latitude_ = value;
}

// required int32 altitude = 3;
inline bool GpsInformation::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpsInformation::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpsInformation::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpsInformation::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline ::google::protobuf::int32 GpsInformation::altitude() const {
  return altitude_;
}
inline void GpsInformation::set_altitude(::google::protobuf::int32 value) {
  set_has_altitude();
  altitude_ = value;
}

// repeated float velocity = 4;
inline int GpsInformation::velocity_size() const {
  return velocity_.size();
}
inline void GpsInformation::clear_velocity() {
  velocity_.Clear();
}
inline float GpsInformation::velocity(int index) const {
  return velocity_.Get(index);
}
inline void GpsInformation::set_velocity(int index, float value) {
  velocity_.Set(index, value);
}
inline void GpsInformation::add_velocity(float value) {
  velocity_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
GpsInformation::velocity() const {
  return velocity_;
}
inline ::google::protobuf::RepeatedField< float >*
GpsInformation::mutable_velocity() {
  return &velocity_;
}

// -------------------------------------------------------------------

// UavAttitude

// required float roll = 1;
inline bool UavAttitude::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UavAttitude::set_has_roll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UavAttitude::clear_has_roll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UavAttitude::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float UavAttitude::roll() const {
  return roll_;
}
inline void UavAttitude::set_roll(float value) {
  set_has_roll();
  roll_ = value;
}

// required float pitch = 2;
inline bool UavAttitude::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UavAttitude::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UavAttitude::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UavAttitude::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float UavAttitude::pitch() const {
  return pitch_;
}
inline void UavAttitude::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
}

// required float yaw = 3;
inline bool UavAttitude::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UavAttitude::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UavAttitude::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UavAttitude::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float UavAttitude::yaw() const {
  return yaw_;
}
inline void UavAttitude::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
}

// required float relative_alt = 4;
inline bool UavAttitude::has_relative_alt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UavAttitude::set_has_relative_alt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UavAttitude::clear_has_relative_alt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UavAttitude::clear_relative_alt() {
  relative_alt_ = 0;
  clear_has_relative_alt();
}
inline float UavAttitude::relative_alt() const {
  return relative_alt_;
}
inline void UavAttitude::set_relative_alt(float value) {
  set_has_relative_alt();
  relative_alt_ = value;
}

// required float groundspeed = 5;
inline bool UavAttitude::has_groundspeed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UavAttitude::set_has_groundspeed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UavAttitude::clear_has_groundspeed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UavAttitude::clear_groundspeed() {
  groundspeed_ = 0;
  clear_has_groundspeed();
}
inline float UavAttitude::groundspeed() const {
  return groundspeed_;
}
inline void UavAttitude::set_groundspeed(float value) {
  set_has_groundspeed();
  groundspeed_ = value;
}

// -------------------------------------------------------------------

// OperationStatus

// optional string operationmode = 1;
inline bool OperationStatus::has_operationmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationStatus::set_has_operationmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationStatus::clear_has_operationmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationStatus::clear_operationmode() {
  if (operationmode_ != &::google::protobuf::internal::kEmptyString) {
    operationmode_->clear();
  }
  clear_has_operationmode();
}
inline const ::std::string& OperationStatus::operationmode() const {
  return *operationmode_;
}
inline void OperationStatus::set_operationmode(const ::std::string& value) {
  set_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    operationmode_ = new ::std::string;
  }
  operationmode_->assign(value);
}
inline void OperationStatus::set_operationmode(const char* value) {
  set_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    operationmode_ = new ::std::string;
  }
  operationmode_->assign(value);
}
inline void OperationStatus::set_operationmode(const char* value, size_t size) {
  set_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    operationmode_ = new ::std::string;
  }
  operationmode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationStatus::mutable_operationmode() {
  set_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    operationmode_ = new ::std::string;
  }
  return operationmode_;
}
inline ::std::string* OperationStatus::release_operationmode() {
  clear_has_operationmode();
  if (operationmode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operationmode_;
    operationmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationStatus::set_allocated_operationmode(::std::string* operationmode) {
  if (operationmode_ != &::google::protobuf::internal::kEmptyString) {
    delete operationmode_;
  }
  if (operationmode) {
    set_has_operationmode();
    operationmode_ = operationmode;
  } else {
    clear_has_operationmode();
    operationmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float voltage = 2;
inline bool OperationStatus::has_voltage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationStatus::set_has_voltage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationStatus::clear_has_voltage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationStatus::clear_voltage() {
  voltage_ = 0;
  clear_has_voltage();
}
inline float OperationStatus::voltage() const {
  return voltage_;
}
inline void OperationStatus::set_voltage(float value) {
  set_has_voltage();
  voltage_ = value;
}

// optional float surplusenergy = 3;
inline bool OperationStatus::has_surplusenergy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationStatus::set_has_surplusenergy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationStatus::clear_has_surplusenergy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationStatus::clear_surplusenergy() {
  surplusenergy_ = 0;
  clear_has_surplusenergy();
}
inline float OperationStatus::surplusenergy() const {
  return surplusenergy_;
}
inline void OperationStatus::set_surplusenergy(float value) {
  set_has_surplusenergy();
  surplusenergy_ = value;
}

// optional float jetvelocity = 4;
inline bool OperationStatus::has_jetvelocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationStatus::set_has_jetvelocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationStatus::clear_has_jetvelocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationStatus::clear_jetvelocity() {
  jetvelocity_ = 0;
  clear_has_jetvelocity();
}
inline float OperationStatus::jetvelocity() const {
  return jetvelocity_;
}
inline void OperationStatus::set_jetvelocity(float value) {
  set_has_jetvelocity();
  jetvelocity_ = value;
}

// optional float sprayeddose = 5;
inline bool OperationStatus::has_sprayeddose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationStatus::set_has_sprayeddose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationStatus::clear_has_sprayeddose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationStatus::clear_sprayeddose() {
  sprayeddose_ = 0;
  clear_has_sprayeddose();
}
inline float OperationStatus::sprayeddose() const {
  return sprayeddose_;
}
inline void OperationStatus::set_sprayeddose(float value) {
  set_has_sprayeddose();
  sprayeddose_ = value;
}

// -------------------------------------------------------------------

// OperationParams

// optional float alarmvoltage = 1;
inline bool OperationParams::has_alarmvoltage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationParams::set_has_alarmvoltage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationParams::clear_has_alarmvoltage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationParams::clear_alarmvoltage() {
  alarmvoltage_ = 0;
  clear_has_alarmvoltage();
}
inline float OperationParams::alarmvoltage() const {
  return alarmvoltage_;
}
inline void OperationParams::set_alarmvoltage(float value) {
  set_has_alarmvoltage();
  alarmvoltage_ = value;
}

// optional float alarmdose = 2;
inline bool OperationParams::has_alarmdose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationParams::set_has_alarmdose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationParams::clear_has_alarmdose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationParams::clear_alarmdose() {
  alarmdose_ = 0;
  clear_has_alarmdose();
}
inline float OperationParams::alarmdose() const {
  return alarmdose_;
}
inline void OperationParams::set_alarmdose(float value) {
  set_has_alarmdose();
  alarmdose_ = value;
}

// optional float sprayingwidth = 3;
inline bool OperationParams::has_sprayingwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationParams::set_has_sprayingwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationParams::clear_has_sprayingwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationParams::clear_sprayingwidth() {
  sprayingwidth_ = 0;
  clear_has_sprayingwidth();
}
inline float OperationParams::sprayingwidth() const {
  return sprayingwidth_;
}
inline void OperationParams::set_sprayingwidth(float value) {
  set_has_sprayingwidth();
  sprayingwidth_ = value;
}

// optional float desiredaltitude = 4;
inline bool OperationParams::has_desiredaltitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationParams::set_has_desiredaltitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationParams::clear_has_desiredaltitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationParams::clear_desiredaltitude() {
  desiredaltitude_ = 0;
  clear_has_desiredaltitude();
}
inline float OperationParams::desiredaltitude() const {
  return desiredaltitude_;
}
inline void OperationParams::set_desiredaltitude(float value) {
  set_has_desiredaltitude();
  desiredaltitude_ = value;
}

// optional float desiredvelocity = 5;
inline bool OperationParams::has_desiredvelocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationParams::set_has_desiredvelocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationParams::clear_has_desiredvelocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationParams::clear_desiredvelocity() {
  desiredvelocity_ = 0;
  clear_has_desiredvelocity();
}
inline float OperationParams::desiredvelocity() const {
  return desiredvelocity_;
}
inline void OperationParams::set_desiredvelocity(float value) {
  set_has_desiredvelocity();
  desiredvelocity_ = value;
}

// optional float jetvelocity = 6;
inline bool OperationParams::has_jetvelocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperationParams::set_has_jetvelocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperationParams::clear_has_jetvelocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperationParams::clear_jetvelocity() {
  jetvelocity_ = 0;
  clear_has_jetvelocity();
}
inline float OperationParams::jetvelocity() const {
  return jetvelocity_;
}
inline void OperationParams::set_jetvelocity(float value) {
  set_has_jetvelocity();
  jetvelocity_ = value;
}

// -------------------------------------------------------------------

// OperationInformation

// required string uavid = 1;
inline bool OperationInformation::has_uavid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationInformation::set_has_uavid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationInformation::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationInformation::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& OperationInformation::uavid() const {
  return *uavid_;
}
inline void OperationInformation::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void OperationInformation::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void OperationInformation::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationInformation::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* OperationInformation::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationInformation::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 timestamp = 2;
inline bool OperationInformation::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationInformation::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationInformation::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationInformation::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 OperationInformation::timestamp() const {
  return timestamp_;
}
inline void OperationInformation::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required .das.proto.GpsInformation gps = 3;
inline bool OperationInformation::has_gps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationInformation::set_has_gps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationInformation::clear_has_gps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationInformation::clear_gps() {
  if (gps_ != NULL) gps_->::das::proto::GpsInformation::Clear();
  clear_has_gps();
}
inline const ::das::proto::GpsInformation& OperationInformation::gps() const {
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::das::proto::GpsInformation* OperationInformation::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::das::proto::GpsInformation;
  return gps_;
}
inline ::das::proto::GpsInformation* OperationInformation::release_gps() {
  clear_has_gps();
  ::das::proto::GpsInformation* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void OperationInformation::set_allocated_gps(::das::proto::GpsInformation* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
}

// optional .das.proto.OperationStatus status = 4;
inline bool OperationInformation::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationInformation::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationInformation::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationInformation::clear_status() {
  if (status_ != NULL) status_->::das::proto::OperationStatus::Clear();
  clear_has_status();
}
inline const ::das::proto::OperationStatus& OperationInformation::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::das::proto::OperationStatus* OperationInformation::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::das::proto::OperationStatus;
  return status_;
}
inline ::das::proto::OperationStatus* OperationInformation::release_status() {
  clear_has_status();
  ::das::proto::OperationStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void OperationInformation::set_allocated_status(::das::proto::OperationStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional .das.proto.OperationParams params = 5;
inline bool OperationInformation::has_params() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationInformation::set_has_params() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationInformation::clear_has_params() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationInformation::clear_params() {
  if (params_ != NULL) params_->::das::proto::OperationParams::Clear();
  clear_has_params();
}
inline const ::das::proto::OperationParams& OperationInformation::params() const {
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::das::proto::OperationParams* OperationInformation::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::das::proto::OperationParams;
  return params_;
}
inline ::das::proto::OperationParams* OperationInformation::release_params() {
  clear_has_params();
  ::das::proto::OperationParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void OperationInformation::set_allocated_params(::das::proto::OperationParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
}

// optional .das.proto.UavAttitude attitude = 6;
inline bool OperationInformation::has_attitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperationInformation::set_has_attitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperationInformation::clear_has_attitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperationInformation::clear_attitude() {
  if (attitude_ != NULL) attitude_->::das::proto::UavAttitude::Clear();
  clear_has_attitude();
}
inline const ::das::proto::UavAttitude& OperationInformation::attitude() const {
  return attitude_ != NULL ? *attitude_ : *default_instance_->attitude_;
}
inline ::das::proto::UavAttitude* OperationInformation::mutable_attitude() {
  set_has_attitude();
  if (attitude_ == NULL) attitude_ = new ::das::proto::UavAttitude;
  return attitude_;
}
inline ::das::proto::UavAttitude* OperationInformation::release_attitude() {
  clear_has_attitude();
  ::das::proto::UavAttitude* temp = attitude_;
  attitude_ = NULL;
  return temp;
}
inline void OperationInformation::set_allocated_attitude(::das::proto::UavAttitude* attitude) {
  delete attitude_;
  attitude_ = attitude;
  if (attitude) {
    set_has_attitude();
  } else {
    clear_has_attitude();
  }
}

// -------------------------------------------------------------------

// PostOperationInformation

// required uint32 seqno = 1;
inline bool PostOperationInformation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostOperationInformation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostOperationInformation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostOperationInformation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostOperationInformation::seqno() const {
  return seqno_;
}
inline void PostOperationInformation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// repeated .das.proto.OperationInformation oi = 2;
inline int PostOperationInformation::oi_size() const {
  return oi_.size();
}
inline void PostOperationInformation::clear_oi() {
  oi_.Clear();
}
inline const ::das::proto::OperationInformation& PostOperationInformation::oi(int index) const {
  return oi_.Get(index);
}
inline ::das::proto::OperationInformation* PostOperationInformation::mutable_oi(int index) {
  return oi_.Mutable(index);
}
inline ::das::proto::OperationInformation* PostOperationInformation::add_oi() {
  return oi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation >&
PostOperationInformation::oi() const {
  return oi_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::OperationInformation >*
PostOperationInformation::mutable_oi() {
  return &oi_;
}

// -------------------------------------------------------------------

// AckOperationInformation

// required uint32 seqno = 1;
inline bool AckOperationInformation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckOperationInformation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckOperationInformation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckOperationInformation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckOperationInformation::seqno() const {
  return seqno_;
}
inline void AckOperationInformation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckOperationInformation::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckOperationInformation::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckOperationInformation::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckOperationInformation::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckOperationInformation::result() const {
  return result_;
}
inline void AckOperationInformation::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// Coordinate

// required int32 longitude = 1;
inline bool Coordinate::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Coordinate::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Coordinate::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Coordinate::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline ::google::protobuf::int32 Coordinate::longitude() const {
  return longitude_;
}
inline void Coordinate::set_longitude(::google::protobuf::int32 value) {
  set_has_longitude();
  longitude_ = value;
}

// required int32 latitude = 2;
inline bool Coordinate::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Coordinate::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Coordinate::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Coordinate::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline ::google::protobuf::int32 Coordinate::latitude() const {
  return latitude_;
}
inline void Coordinate::set_latitude(::google::protobuf::int32 value) {
  set_has_latitude();
  latitude_ = value;
}

// optional int32 altitude = 3;
inline bool Coordinate::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Coordinate::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Coordinate::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Coordinate::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline ::google::protobuf::int32 Coordinate::altitude() const {
  return altitude_;
}
inline void Coordinate::set_altitude(::google::protobuf::int32 value) {
  set_has_altitude();
  altitude_ = value;
}

// -------------------------------------------------------------------

// OperationSnapshot

// required string devid = 1;
inline bool OperationSnapshot::has_devid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationSnapshot::set_has_devid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationSnapshot::clear_has_devid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationSnapshot::clear_devid() {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    devid_->clear();
  }
  clear_has_devid();
}
inline const ::std::string& OperationSnapshot::devid() const {
  return *devid_;
}
inline void OperationSnapshot::set_devid(const ::std::string& value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void OperationSnapshot::set_devid(const char* value) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(value);
}
inline void OperationSnapshot::set_devid(const char* value, size_t size) {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  devid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationSnapshot::mutable_devid() {
  set_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    devid_ = new ::std::string;
  }
  return devid_;
}
inline ::std::string* OperationSnapshot::release_devid() {
  clear_has_devid();
  if (devid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devid_;
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationSnapshot::set_allocated_devid(::std::string* devid) {
  if (devid_ != &::google::protobuf::internal::kEmptyString) {
    delete devid_;
  }
  if (devid) {
    set_has_devid();
    devid_ = devid;
  } else {
    clear_has_devid();
    devid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 timestamp = 2;
inline bool OperationSnapshot::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationSnapshot::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationSnapshot::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationSnapshot::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 OperationSnapshot::timestamp() const {
  return timestamp_;
}
inline void OperationSnapshot::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .das.proto.Coordinate pos = 3;
inline bool OperationSnapshot::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationSnapshot::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationSnapshot::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationSnapshot::clear_pos() {
  if (pos_ != NULL) pos_->::das::proto::Coordinate::Clear();
  clear_has_pos();
}
inline const ::das::proto::Coordinate& OperationSnapshot::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::das::proto::Coordinate* OperationSnapshot::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::das::proto::Coordinate;
  return pos_;
}
inline ::das::proto::Coordinate* OperationSnapshot::release_pos() {
  clear_has_pos();
  ::das::proto::Coordinate* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void OperationSnapshot::set_allocated_pos(::das::proto::Coordinate* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// optional int32 size = 4;
inline bool OperationSnapshot::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationSnapshot::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationSnapshot::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationSnapshot::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 OperationSnapshot::size() const {
  return size_;
}
inline void OperationSnapshot::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// required bytes pic = 5;
inline bool OperationSnapshot::has_pic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationSnapshot::set_has_pic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationSnapshot::clear_has_pic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationSnapshot::clear_pic() {
  if (pic_ != &::google::protobuf::internal::kEmptyString) {
    pic_->clear();
  }
  clear_has_pic();
}
inline const ::std::string& OperationSnapshot::pic() const {
  return *pic_;
}
inline void OperationSnapshot::set_pic(const ::std::string& value) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void OperationSnapshot::set_pic(const char* value) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void OperationSnapshot::set_pic(const void* value, size_t size) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationSnapshot::mutable_pic() {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  return pic_;
}
inline ::std::string* OperationSnapshot::release_pic() {
  clear_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pic_;
    pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationSnapshot::set_allocated_pic(::std::string* pic) {
  if (pic_ != &::google::protobuf::internal::kEmptyString) {
    delete pic_;
  }
  if (pic) {
    set_has_pic();
    pic_ = pic;
  } else {
    clear_has_pic();
    pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostOperationSnapshot

// required uint32 seqno = 1;
inline bool PostOperationSnapshot::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostOperationSnapshot::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostOperationSnapshot::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostOperationSnapshot::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostOperationSnapshot::seqno() const {
  return seqno_;
}
inline void PostOperationSnapshot::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required .das.proto.OperationSnapshot os = 2;
inline bool PostOperationSnapshot::has_os() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostOperationSnapshot::set_has_os() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostOperationSnapshot::clear_has_os() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostOperationSnapshot::clear_os() {
  if (os_ != NULL) os_->::das::proto::OperationSnapshot::Clear();
  clear_has_os();
}
inline const ::das::proto::OperationSnapshot& PostOperationSnapshot::os() const {
  return os_ != NULL ? *os_ : *default_instance_->os_;
}
inline ::das::proto::OperationSnapshot* PostOperationSnapshot::mutable_os() {
  set_has_os();
  if (os_ == NULL) os_ = new ::das::proto::OperationSnapshot;
  return os_;
}
inline ::das::proto::OperationSnapshot* PostOperationSnapshot::release_os() {
  clear_has_os();
  ::das::proto::OperationSnapshot* temp = os_;
  os_ = NULL;
  return temp;
}
inline void PostOperationSnapshot::set_allocated_os(::das::proto::OperationSnapshot* os) {
  delete os_;
  os_ = os;
  if (os) {
    set_has_os();
  } else {
    clear_has_os();
  }
}

// -------------------------------------------------------------------

// AckPostOperationSnapshot

// required uint32 seqno = 1;
inline bool AckPostOperationSnapshot::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostOperationSnapshot::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostOperationSnapshot::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostOperationSnapshot::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostOperationSnapshot::seqno() const {
  return seqno_;
}
inline void AckPostOperationSnapshot::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPostOperationSnapshot::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostOperationSnapshot::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostOperationSnapshot::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostOperationSnapshot::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPostOperationSnapshot::result() const {
  return result_;
}
inline void AckPostOperationSnapshot::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// Outline

// repeated .das.proto.Coordinate coordinates = 1;
inline int Outline::coordinates_size() const {
  return coordinates_.size();
}
inline void Outline::clear_coordinates() {
  coordinates_.Clear();
}
inline const ::das::proto::Coordinate& Outline::coordinates(int index) const {
  return coordinates_.Get(index);
}
inline ::das::proto::Coordinate* Outline::mutable_coordinates(int index) {
  return coordinates_.Mutable(index);
}
inline ::das::proto::Coordinate* Outline::add_coordinates() {
  return coordinates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate >&
Outline::coordinates() const {
  return coordinates_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate >*
Outline::mutable_coordinates() {
  return &coordinates_;
}

// -------------------------------------------------------------------

// ParcelSurveyInformation

// required string surveryorid = 1;
inline bool ParcelSurveyInformation::has_surveryorid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParcelSurveyInformation::set_has_surveryorid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParcelSurveyInformation::clear_has_surveryorid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParcelSurveyInformation::clear_surveryorid() {
  if (surveryorid_ != &::google::protobuf::internal::kEmptyString) {
    surveryorid_->clear();
  }
  clear_has_surveryorid();
}
inline const ::std::string& ParcelSurveyInformation::surveryorid() const {
  return *surveryorid_;
}
inline void ParcelSurveyInformation::set_surveryorid(const ::std::string& value) {
  set_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    surveryorid_ = new ::std::string;
  }
  surveryorid_->assign(value);
}
inline void ParcelSurveyInformation::set_surveryorid(const char* value) {
  set_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    surveryorid_ = new ::std::string;
  }
  surveryorid_->assign(value);
}
inline void ParcelSurveyInformation::set_surveryorid(const char* value, size_t size) {
  set_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    surveryorid_ = new ::std::string;
  }
  surveryorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelSurveyInformation::mutable_surveryorid() {
  set_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    surveryorid_ = new ::std::string;
  }
  return surveryorid_;
}
inline ::std::string* ParcelSurveyInformation::release_surveryorid() {
  clear_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = surveryorid_;
    surveryorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelSurveyInformation::set_allocated_surveryorid(::std::string* surveryorid) {
  if (surveryorid_ != &::google::protobuf::internal::kEmptyString) {
    delete surveryorid_;
  }
  if (surveryorid) {
    set_has_surveryorid();
    surveryorid_ = surveryorid;
  } else {
    clear_has_surveryorid();
    surveryorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 surverytime = 2;
inline bool ParcelSurveyInformation::has_surverytime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParcelSurveyInformation::set_has_surverytime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParcelSurveyInformation::clear_has_surverytime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParcelSurveyInformation::clear_surverytime() {
  surverytime_ = GOOGLE_ULONGLONG(0);
  clear_has_surverytime();
}
inline ::google::protobuf::uint64 ParcelSurveyInformation::surverytime() const {
  return surverytime_;
}
inline void ParcelSurveyInformation::set_surverytime(::google::protobuf::uint64 value) {
  set_has_surverytime();
  surverytime_ = value;
}

// required .das.proto.SurveryPrecision sp = 3;
inline bool ParcelSurveyInformation::has_sp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParcelSurveyInformation::set_has_sp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParcelSurveyInformation::clear_has_sp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParcelSurveyInformation::clear_sp() {
  sp_ = 1;
  clear_has_sp();
}
inline ::das::proto::SurveryPrecision ParcelSurveyInformation::sp() const {
  return static_cast< ::das::proto::SurveryPrecision >(sp_);
}
inline void ParcelSurveyInformation::set_sp(::das::proto::SurveryPrecision value) {
  assert(::das::proto::SurveryPrecision_IsValid(value));
  set_has_sp();
  sp_ = value;
}

// required .das.proto.Outline po = 4;
inline bool ParcelSurveyInformation::has_po() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParcelSurveyInformation::set_has_po() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParcelSurveyInformation::clear_has_po() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParcelSurveyInformation::clear_po() {
  if (po_ != NULL) po_->::das::proto::Outline::Clear();
  clear_has_po();
}
inline const ::das::proto::Outline& ParcelSurveyInformation::po() const {
  return po_ != NULL ? *po_ : *default_instance_->po_;
}
inline ::das::proto::Outline* ParcelSurveyInformation::mutable_po() {
  set_has_po();
  if (po_ == NULL) po_ = new ::das::proto::Outline;
  return po_;
}
inline ::das::proto::Outline* ParcelSurveyInformation::release_po() {
  clear_has_po();
  ::das::proto::Outline* temp = po_;
  po_ = NULL;
  return temp;
}
inline void ParcelSurveyInformation::set_allocated_po(::das::proto::Outline* po) {
  delete po_;
  po_ = po;
  if (po) {
    set_has_po();
  } else {
    clear_has_po();
  }
}

// repeated .das.proto.Outline bo = 5;
inline int ParcelSurveyInformation::bo_size() const {
  return bo_.size();
}
inline void ParcelSurveyInformation::clear_bo() {
  bo_.Clear();
}
inline const ::das::proto::Outline& ParcelSurveyInformation::bo(int index) const {
  return bo_.Get(index);
}
inline ::das::proto::Outline* ParcelSurveyInformation::mutable_bo(int index) {
  return bo_.Mutable(index);
}
inline ::das::proto::Outline* ParcelSurveyInformation::add_bo() {
  return bo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::Outline >&
ParcelSurveyInformation::bo() const {
  return bo_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::Outline >*
ParcelSurveyInformation::mutable_bo() {
  return &bo_;
}

// optional string id = 6;
inline bool ParcelSurveyInformation::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParcelSurveyInformation::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParcelSurveyInformation::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParcelSurveyInformation::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ParcelSurveyInformation::id() const {
  return *id_;
}
inline void ParcelSurveyInformation::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ParcelSurveyInformation::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ParcelSurveyInformation::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelSurveyInformation::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ParcelSurveyInformation::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelSurveyInformation::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostParcelSurveyInformation

// required uint32 seqno = 1;
inline bool PostParcelSurveyInformation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostParcelSurveyInformation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostParcelSurveyInformation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostParcelSurveyInformation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostParcelSurveyInformation::seqno() const {
  return seqno_;
}
inline void PostParcelSurveyInformation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required .das.proto.ParcelSurveyInformation psi = 2;
inline bool PostParcelSurveyInformation::has_psi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostParcelSurveyInformation::set_has_psi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostParcelSurveyInformation::clear_has_psi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostParcelSurveyInformation::clear_psi() {
  if (psi_ != NULL) psi_->::das::proto::ParcelSurveyInformation::Clear();
  clear_has_psi();
}
inline const ::das::proto::ParcelSurveyInformation& PostParcelSurveyInformation::psi() const {
  return psi_ != NULL ? *psi_ : *default_instance_->psi_;
}
inline ::das::proto::ParcelSurveyInformation* PostParcelSurveyInformation::mutable_psi() {
  set_has_psi();
  if (psi_ == NULL) psi_ = new ::das::proto::ParcelSurveyInformation;
  return psi_;
}
inline ::das::proto::ParcelSurveyInformation* PostParcelSurveyInformation::release_psi() {
  clear_has_psi();
  ::das::proto::ParcelSurveyInformation* temp = psi_;
  psi_ = NULL;
  return temp;
}
inline void PostParcelSurveyInformation::set_allocated_psi(::das::proto::ParcelSurveyInformation* psi) {
  delete psi_;
  psi_ = psi;
  if (psi) {
    set_has_psi();
  } else {
    clear_has_psi();
  }
}

// -------------------------------------------------------------------

// AckPostParcelSurveyInformation

// required uint32 seqno = 1;
inline bool AckPostParcelSurveyInformation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostParcelSurveyInformation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostParcelSurveyInformation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostParcelSurveyInformation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostParcelSurveyInformation::seqno() const {
  return seqno_;
}
inline void AckPostParcelSurveyInformation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPostParcelSurveyInformation::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostParcelSurveyInformation::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostParcelSurveyInformation::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostParcelSurveyInformation::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPostParcelSurveyInformation::result() const {
  return result_;
}
inline void AckPostParcelSurveyInformation::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string psiid = 3;
inline bool AckPostParcelSurveyInformation::has_psiid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckPostParcelSurveyInformation::set_has_psiid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckPostParcelSurveyInformation::clear_has_psiid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckPostParcelSurveyInformation::clear_psiid() {
  if (psiid_ != &::google::protobuf::internal::kEmptyString) {
    psiid_->clear();
  }
  clear_has_psiid();
}
inline const ::std::string& AckPostParcelSurveyInformation::psiid() const {
  return *psiid_;
}
inline void AckPostParcelSurveyInformation::set_psiid(const ::std::string& value) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(value);
}
inline void AckPostParcelSurveyInformation::set_psiid(const char* value) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(value);
}
inline void AckPostParcelSurveyInformation::set_psiid(const char* value, size_t size) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPostParcelSurveyInformation::mutable_psiid() {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  return psiid_;
}
inline ::std::string* AckPostParcelSurveyInformation::release_psiid() {
  clear_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = psiid_;
    psiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPostParcelSurveyInformation::set_allocated_psiid(::std::string* psiid) {
  if (psiid_ != &::google::protobuf::internal::kEmptyString) {
    delete psiid_;
  }
  if (psiid) {
    set_has_psiid();
    psiid_ = psiid;
  } else {
    clear_has_psiid();
    psiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestParcelSurveyInformations

// required uint32 seqno = 1;
inline bool RequestParcelSurveyInformations::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestParcelSurveyInformations::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestParcelSurveyInformations::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestParcelSurveyInformations::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestParcelSurveyInformations::seqno() const {
  return seqno_;
}
inline void RequestParcelSurveyInformations::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional string psiid = 2;
inline bool RequestParcelSurveyInformations::has_psiid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestParcelSurveyInformations::set_has_psiid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestParcelSurveyInformations::clear_has_psiid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestParcelSurveyInformations::clear_psiid() {
  if (psiid_ != &::google::protobuf::internal::kEmptyString) {
    psiid_->clear();
  }
  clear_has_psiid();
}
inline const ::std::string& RequestParcelSurveyInformations::psiid() const {
  return *psiid_;
}
inline void RequestParcelSurveyInformations::set_psiid(const ::std::string& value) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(value);
}
inline void RequestParcelSurveyInformations::set_psiid(const char* value) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(value);
}
inline void RequestParcelSurveyInformations::set_psiid(const char* value, size_t size) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestParcelSurveyInformations::mutable_psiid() {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  return psiid_;
}
inline ::std::string* RequestParcelSurveyInformations::release_psiid() {
  clear_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = psiid_;
    psiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestParcelSurveyInformations::set_allocated_psiid(::std::string* psiid) {
  if (psiid_ != &::google::protobuf::internal::kEmptyString) {
    delete psiid_;
  }
  if (psiid) {
    set_has_psiid();
    psiid_ = psiid;
  } else {
    clear_has_psiid();
    psiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .das.proto.Coordinate coordinate = 3;
inline bool RequestParcelSurveyInformations::has_coordinate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestParcelSurveyInformations::set_has_coordinate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestParcelSurveyInformations::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestParcelSurveyInformations::clear_coordinate() {
  if (coordinate_ != NULL) coordinate_->::das::proto::Coordinate::Clear();
  clear_has_coordinate();
}
inline const ::das::proto::Coordinate& RequestParcelSurveyInformations::coordinate() const {
  return coordinate_ != NULL ? *coordinate_ : *default_instance_->coordinate_;
}
inline ::das::proto::Coordinate* RequestParcelSurveyInformations::mutable_coordinate() {
  set_has_coordinate();
  if (coordinate_ == NULL) coordinate_ = new ::das::proto::Coordinate;
  return coordinate_;
}
inline ::das::proto::Coordinate* RequestParcelSurveyInformations::release_coordinate() {
  clear_has_coordinate();
  ::das::proto::Coordinate* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline void RequestParcelSurveyInformations::set_allocated_coordinate(::das::proto::Coordinate* coordinate) {
  delete coordinate_;
  coordinate_ = coordinate;
  if (coordinate) {
    set_has_coordinate();
  } else {
    clear_has_coordinate();
  }
}

// -------------------------------------------------------------------

// AckRequestParcelSurveyInformations

// required uint32 seqno = 1;
inline bool AckRequestParcelSurveyInformations::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRequestParcelSurveyInformations::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRequestParcelSurveyInformations::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRequestParcelSurveyInformations::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckRequestParcelSurveyInformations::seqno() const {
  return seqno_;
}
inline void AckRequestParcelSurveyInformations::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckRequestParcelSurveyInformations::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRequestParcelSurveyInformations::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRequestParcelSurveyInformations::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRequestParcelSurveyInformations::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckRequestParcelSurveyInformations::result() const {
  return result_;
}
inline void AckRequestParcelSurveyInformations::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated .das.proto.ParcelSurveyInformation psis = 3;
inline int AckRequestParcelSurveyInformations::psis_size() const {
  return psis_.size();
}
inline void AckRequestParcelSurveyInformations::clear_psis() {
  psis_.Clear();
}
inline const ::das::proto::ParcelSurveyInformation& AckRequestParcelSurveyInformations::psis(int index) const {
  return psis_.Get(index);
}
inline ::das::proto::ParcelSurveyInformation* AckRequestParcelSurveyInformations::mutable_psis(int index) {
  return psis_.Mutable(index);
}
inline ::das::proto::ParcelSurveyInformation* AckRequestParcelSurveyInformations::add_psis() {
  return psis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelSurveyInformation >&
AckRequestParcelSurveyInformations::psis() const {
  return psis_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelSurveyInformation >*
AckRequestParcelSurveyInformations::mutable_psis() {
  return &psis_;
}

// -------------------------------------------------------------------

// ParcelContracter

// required string name = 1;
inline bool ParcelContracter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParcelContracter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParcelContracter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParcelContracter::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ParcelContracter::name() const {
  return *name_;
}
inline void ParcelContracter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParcelContracter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParcelContracter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelContracter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ParcelContracter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelContracter::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 birthdate = 2;
inline bool ParcelContracter::has_birthdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParcelContracter::set_has_birthdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParcelContracter::clear_has_birthdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParcelContracter::clear_birthdate() {
  birthdate_ = GOOGLE_ULONGLONG(0);
  clear_has_birthdate();
}
inline ::google::protobuf::uint64 ParcelContracter::birthdate() const {
  return birthdate_;
}
inline void ParcelContracter::set_birthdate(::google::protobuf::uint64 value) {
  set_has_birthdate();
  birthdate_ = value;
}

// required string address = 3;
inline bool ParcelContracter::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParcelContracter::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParcelContracter::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParcelContracter::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& ParcelContracter::address() const {
  return *address_;
}
inline void ParcelContracter::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ParcelContracter::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ParcelContracter::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelContracter::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* ParcelContracter::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelContracter::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string mobileno = 4;
inline bool ParcelContracter::has_mobileno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParcelContracter::set_has_mobileno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParcelContracter::clear_has_mobileno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParcelContracter::clear_mobileno() {
  if (mobileno_ != &::google::protobuf::internal::kEmptyString) {
    mobileno_->clear();
  }
  clear_has_mobileno();
}
inline const ::std::string& ParcelContracter::mobileno() const {
  return *mobileno_;
}
inline void ParcelContracter::set_mobileno(const ::std::string& value) {
  set_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    mobileno_ = new ::std::string;
  }
  mobileno_->assign(value);
}
inline void ParcelContracter::set_mobileno(const char* value) {
  set_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    mobileno_ = new ::std::string;
  }
  mobileno_->assign(value);
}
inline void ParcelContracter::set_mobileno(const char* value, size_t size) {
  set_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    mobileno_ = new ::std::string;
  }
  mobileno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelContracter::mutable_mobileno() {
  set_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    mobileno_ = new ::std::string;
  }
  return mobileno_;
}
inline ::std::string* ParcelContracter::release_mobileno() {
  clear_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobileno_;
    mobileno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelContracter::set_allocated_mobileno(::std::string* mobileno) {
  if (mobileno_ != &::google::protobuf::internal::kEmptyString) {
    delete mobileno_;
  }
  if (mobileno) {
    set_has_mobileno();
    mobileno_ = mobileno;
  } else {
    clear_has_mobileno();
    mobileno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phoneno = 5;
inline bool ParcelContracter::has_phoneno() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParcelContracter::set_has_phoneno() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParcelContracter::clear_has_phoneno() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParcelContracter::clear_phoneno() {
  if (phoneno_ != &::google::protobuf::internal::kEmptyString) {
    phoneno_->clear();
  }
  clear_has_phoneno();
}
inline const ::std::string& ParcelContracter::phoneno() const {
  return *phoneno_;
}
inline void ParcelContracter::set_phoneno(const ::std::string& value) {
  set_has_phoneno();
  if (phoneno_ == &::google::protobuf::internal::kEmptyString) {
    phoneno_ = new ::std::string;
  }
  phoneno_->assign(value);
}
inline void ParcelContracter::set_phoneno(const char* value) {
  set_has_phoneno();
  if (phoneno_ == &::google::protobuf::internal::kEmptyString) {
    phoneno_ = new ::std::string;
  }
  phoneno_->assign(value);
}
inline void ParcelContracter::set_phoneno(const char* value, size_t size) {
  set_has_phoneno();
  if (phoneno_ == &::google::protobuf::internal::kEmptyString) {
    phoneno_ = new ::std::string;
  }
  phoneno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelContracter::mutable_phoneno() {
  set_has_phoneno();
  if (phoneno_ == &::google::protobuf::internal::kEmptyString) {
    phoneno_ = new ::std::string;
  }
  return phoneno_;
}
inline ::std::string* ParcelContracter::release_phoneno() {
  clear_has_phoneno();
  if (phoneno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phoneno_;
    phoneno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelContracter::set_allocated_phoneno(::std::string* phoneno) {
  if (phoneno_ != &::google::protobuf::internal::kEmptyString) {
    delete phoneno_;
  }
  if (phoneno) {
    set_has_phoneno();
    phoneno_ = phoneno;
  } else {
    clear_has_phoneno();
    phoneno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string weixin = 6;
inline bool ParcelContracter::has_weixin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParcelContracter::set_has_weixin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParcelContracter::clear_has_weixin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParcelContracter::clear_weixin() {
  if (weixin_ != &::google::protobuf::internal::kEmptyString) {
    weixin_->clear();
  }
  clear_has_weixin();
}
inline const ::std::string& ParcelContracter::weixin() const {
  return *weixin_;
}
inline void ParcelContracter::set_weixin(const ::std::string& value) {
  set_has_weixin();
  if (weixin_ == &::google::protobuf::internal::kEmptyString) {
    weixin_ = new ::std::string;
  }
  weixin_->assign(value);
}
inline void ParcelContracter::set_weixin(const char* value) {
  set_has_weixin();
  if (weixin_ == &::google::protobuf::internal::kEmptyString) {
    weixin_ = new ::std::string;
  }
  weixin_->assign(value);
}
inline void ParcelContracter::set_weixin(const char* value, size_t size) {
  set_has_weixin();
  if (weixin_ == &::google::protobuf::internal::kEmptyString) {
    weixin_ = new ::std::string;
  }
  weixin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelContracter::mutable_weixin() {
  set_has_weixin();
  if (weixin_ == &::google::protobuf::internal::kEmptyString) {
    weixin_ = new ::std::string;
  }
  return weixin_;
}
inline ::std::string* ParcelContracter::release_weixin() {
  clear_has_weixin();
  if (weixin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weixin_;
    weixin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelContracter::set_allocated_weixin(::std::string* weixin) {
  if (weixin_ != &::google::protobuf::internal::kEmptyString) {
    delete weixin_;
  }
  if (weixin) {
    set_has_weixin();
    weixin_ = weixin;
  } else {
    clear_has_weixin();
    weixin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 7;
inline bool ParcelContracter::has_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ParcelContracter::set_has_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ParcelContracter::clear_has_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ParcelContracter::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ParcelContracter::id() const {
  return *id_;
}
inline void ParcelContracter::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ParcelContracter::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ParcelContracter::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelContracter::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ParcelContracter::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelContracter::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ParcelDescription

// required string name = 1;
inline bool ParcelDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParcelDescription::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParcelDescription::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParcelDescription::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ParcelDescription::name() const {
  return *name_;
}
inline void ParcelDescription::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParcelDescription::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParcelDescription::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelDescription::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ParcelDescription::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelDescription::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string registerid = 2;
inline bool ParcelDescription::has_registerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParcelDescription::set_has_registerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParcelDescription::clear_has_registerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParcelDescription::clear_registerid() {
  if (registerid_ != &::google::protobuf::internal::kEmptyString) {
    registerid_->clear();
  }
  clear_has_registerid();
}
inline const ::std::string& ParcelDescription::registerid() const {
  return *registerid_;
}
inline void ParcelDescription::set_registerid(const ::std::string& value) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(value);
}
inline void ParcelDescription::set_registerid(const char* value) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(value);
}
inline void ParcelDescription::set_registerid(const char* value, size_t size) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelDescription::mutable_registerid() {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  return registerid_;
}
inline ::std::string* ParcelDescription::release_registerid() {
  clear_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = registerid_;
    registerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelDescription::set_allocated_registerid(::std::string* registerid) {
  if (registerid_ != &::google::protobuf::internal::kEmptyString) {
    delete registerid_;
  }
  if (registerid) {
    set_has_registerid();
    registerid_ = registerid;
  } else {
    clear_has_registerid();
    registerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .das.proto.ParcelContracter pc = 3;
inline bool ParcelDescription::has_pc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParcelDescription::set_has_pc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParcelDescription::clear_has_pc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParcelDescription::clear_pc() {
  if (pc_ != NULL) pc_->::das::proto::ParcelContracter::Clear();
  clear_has_pc();
}
inline const ::das::proto::ParcelContracter& ParcelDescription::pc() const {
  return pc_ != NULL ? *pc_ : *default_instance_->pc_;
}
inline ::das::proto::ParcelContracter* ParcelDescription::mutable_pc() {
  set_has_pc();
  if (pc_ == NULL) pc_ = new ::das::proto::ParcelContracter;
  return pc_;
}
inline ::das::proto::ParcelContracter* ParcelDescription::release_pc() {
  clear_has_pc();
  ::das::proto::ParcelContracter* temp = pc_;
  pc_ = NULL;
  return temp;
}
inline void ParcelDescription::set_allocated_pc(::das::proto::ParcelContracter* pc) {
  delete pc_;
  pc_ = pc;
  if (pc) {
    set_has_pc();
  } else {
    clear_has_pc();
  }
}

// required float acreage = 4;
inline bool ParcelDescription::has_acreage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParcelDescription::set_has_acreage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParcelDescription::clear_has_acreage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParcelDescription::clear_acreage() {
  acreage_ = 0;
  clear_has_acreage();
}
inline float ParcelDescription::acreage() const {
  return acreage_;
}
inline void ParcelDescription::set_acreage(float value) {
  set_has_acreage();
  acreage_ = value;
}

// optional string psiid = 5;
inline bool ParcelDescription::has_psiid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParcelDescription::set_has_psiid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParcelDescription::clear_has_psiid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParcelDescription::clear_psiid() {
  if (psiid_ != &::google::protobuf::internal::kEmptyString) {
    psiid_->clear();
  }
  clear_has_psiid();
}
inline const ::std::string& ParcelDescription::psiid() const {
  return *psiid_;
}
inline void ParcelDescription::set_psiid(const ::std::string& value) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(value);
}
inline void ParcelDescription::set_psiid(const char* value) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(value);
}
inline void ParcelDescription::set_psiid(const char* value, size_t size) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelDescription::mutable_psiid() {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  return psiid_;
}
inline ::std::string* ParcelDescription::release_psiid() {
  clear_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = psiid_;
    psiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelDescription::set_allocated_psiid(::std::string* psiid) {
  if (psiid_ != &::google::protobuf::internal::kEmptyString) {
    delete psiid_;
  }
  if (psiid) {
    set_has_psiid();
    psiid_ = psiid;
  } else {
    clear_has_psiid();
    psiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .das.proto.ParcelSurveyInformation psi = 6;
inline bool ParcelDescription::has_psi() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParcelDescription::set_has_psi() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParcelDescription::clear_has_psi() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParcelDescription::clear_psi() {
  if (psi_ != NULL) psi_->::das::proto::ParcelSurveyInformation::Clear();
  clear_has_psi();
}
inline const ::das::proto::ParcelSurveyInformation& ParcelDescription::psi() const {
  return psi_ != NULL ? *psi_ : *default_instance_->psi_;
}
inline ::das::proto::ParcelSurveyInformation* ParcelDescription::mutable_psi() {
  set_has_psi();
  if (psi_ == NULL) psi_ = new ::das::proto::ParcelSurveyInformation;
  return psi_;
}
inline ::das::proto::ParcelSurveyInformation* ParcelDescription::release_psi() {
  clear_has_psi();
  ::das::proto::ParcelSurveyInformation* temp = psi_;
  psi_ = NULL;
  return temp;
}
inline void ParcelDescription::set_allocated_psi(::das::proto::ParcelSurveyInformation* psi) {
  delete psi_;
  psi_ = psi;
  if (psi) {
    set_has_psi();
  } else {
    clear_has_psi();
  }
}

// optional .das.proto.Coordinate coordinate = 7;
inline bool ParcelDescription::has_coordinate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ParcelDescription::set_has_coordinate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ParcelDescription::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ParcelDescription::clear_coordinate() {
  if (coordinate_ != NULL) coordinate_->::das::proto::Coordinate::Clear();
  clear_has_coordinate();
}
inline const ::das::proto::Coordinate& ParcelDescription::coordinate() const {
  return coordinate_ != NULL ? *coordinate_ : *default_instance_->coordinate_;
}
inline ::das::proto::Coordinate* ParcelDescription::mutable_coordinate() {
  set_has_coordinate();
  if (coordinate_ == NULL) coordinate_ = new ::das::proto::Coordinate;
  return coordinate_;
}
inline ::das::proto::Coordinate* ParcelDescription::release_coordinate() {
  clear_has_coordinate();
  ::das::proto::Coordinate* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline void ParcelDescription::set_allocated_coordinate(::das::proto::Coordinate* coordinate) {
  delete coordinate_;
  coordinate_ = coordinate;
  if (coordinate) {
    set_has_coordinate();
  } else {
    clear_has_coordinate();
  }
}

// optional string id = 8;
inline bool ParcelDescription::has_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ParcelDescription::set_has_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ParcelDescription::clear_has_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ParcelDescription::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ParcelDescription::id() const {
  return *id_;
}
inline void ParcelDescription::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ParcelDescription::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ParcelDescription::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParcelDescription::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ParcelDescription::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParcelDescription::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostParcelDescription

// required uint32 seqno = 1;
inline bool PostParcelDescription::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostParcelDescription::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostParcelDescription::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostParcelDescription::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostParcelDescription::seqno() const {
  return seqno_;
}
inline void PostParcelDescription::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required .das.proto.ParcelDescription pd = 2;
inline bool PostParcelDescription::has_pd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostParcelDescription::set_has_pd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostParcelDescription::clear_has_pd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostParcelDescription::clear_pd() {
  if (pd_ != NULL) pd_->::das::proto::ParcelDescription::Clear();
  clear_has_pd();
}
inline const ::das::proto::ParcelDescription& PostParcelDescription::pd() const {
  return pd_ != NULL ? *pd_ : *default_instance_->pd_;
}
inline ::das::proto::ParcelDescription* PostParcelDescription::mutable_pd() {
  set_has_pd();
  if (pd_ == NULL) pd_ = new ::das::proto::ParcelDescription;
  return pd_;
}
inline ::das::proto::ParcelDescription* PostParcelDescription::release_pd() {
  clear_has_pd();
  ::das::proto::ParcelDescription* temp = pd_;
  pd_ = NULL;
  return temp;
}
inline void PostParcelDescription::set_allocated_pd(::das::proto::ParcelDescription* pd) {
  delete pd_;
  pd_ = pd;
  if (pd) {
    set_has_pd();
  } else {
    clear_has_pd();
  }
}

// -------------------------------------------------------------------

// AckPostParcelDescription

// required uint32 seqno = 1;
inline bool AckPostParcelDescription::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostParcelDescription::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostParcelDescription::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostParcelDescription::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostParcelDescription::seqno() const {
  return seqno_;
}
inline void AckPostParcelDescription::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPostParcelDescription::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostParcelDescription::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostParcelDescription::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostParcelDescription::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPostParcelDescription::result() const {
  return result_;
}
inline void AckPostParcelDescription::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string pcid = 3;
inline bool AckPostParcelDescription::has_pcid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckPostParcelDescription::set_has_pcid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckPostParcelDescription::clear_has_pcid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckPostParcelDescription::clear_pcid() {
  if (pcid_ != &::google::protobuf::internal::kEmptyString) {
    pcid_->clear();
  }
  clear_has_pcid();
}
inline const ::std::string& AckPostParcelDescription::pcid() const {
  return *pcid_;
}
inline void AckPostParcelDescription::set_pcid(const ::std::string& value) {
  set_has_pcid();
  if (pcid_ == &::google::protobuf::internal::kEmptyString) {
    pcid_ = new ::std::string;
  }
  pcid_->assign(value);
}
inline void AckPostParcelDescription::set_pcid(const char* value) {
  set_has_pcid();
  if (pcid_ == &::google::protobuf::internal::kEmptyString) {
    pcid_ = new ::std::string;
  }
  pcid_->assign(value);
}
inline void AckPostParcelDescription::set_pcid(const char* value, size_t size) {
  set_has_pcid();
  if (pcid_ == &::google::protobuf::internal::kEmptyString) {
    pcid_ = new ::std::string;
  }
  pcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPostParcelDescription::mutable_pcid() {
  set_has_pcid();
  if (pcid_ == &::google::protobuf::internal::kEmptyString) {
    pcid_ = new ::std::string;
  }
  return pcid_;
}
inline ::std::string* AckPostParcelDescription::release_pcid() {
  clear_has_pcid();
  if (pcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pcid_;
    pcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPostParcelDescription::set_allocated_pcid(::std::string* pcid) {
  if (pcid_ != &::google::protobuf::internal::kEmptyString) {
    delete pcid_;
  }
  if (pcid) {
    set_has_pcid();
    pcid_ = pcid;
  } else {
    clear_has_pcid();
    pcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string psiid = 4;
inline bool AckPostParcelDescription::has_psiid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckPostParcelDescription::set_has_psiid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckPostParcelDescription::clear_has_psiid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckPostParcelDescription::clear_psiid() {
  if (psiid_ != &::google::protobuf::internal::kEmptyString) {
    psiid_->clear();
  }
  clear_has_psiid();
}
inline const ::std::string& AckPostParcelDescription::psiid() const {
  return *psiid_;
}
inline void AckPostParcelDescription::set_psiid(const ::std::string& value) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(value);
}
inline void AckPostParcelDescription::set_psiid(const char* value) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(value);
}
inline void AckPostParcelDescription::set_psiid(const char* value, size_t size) {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  psiid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPostParcelDescription::mutable_psiid() {
  set_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    psiid_ = new ::std::string;
  }
  return psiid_;
}
inline ::std::string* AckPostParcelDescription::release_psiid() {
  clear_has_psiid();
  if (psiid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = psiid_;
    psiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPostParcelDescription::set_allocated_psiid(::std::string* psiid) {
  if (psiid_ != &::google::protobuf::internal::kEmptyString) {
    delete psiid_;
  }
  if (psiid) {
    set_has_psiid();
    psiid_ = psiid;
  } else {
    clear_has_psiid();
    psiid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pdid = 5;
inline bool AckPostParcelDescription::has_pdid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckPostParcelDescription::set_has_pdid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckPostParcelDescription::clear_has_pdid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckPostParcelDescription::clear_pdid() {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    pdid_->clear();
  }
  clear_has_pdid();
}
inline const ::std::string& AckPostParcelDescription::pdid() const {
  return *pdid_;
}
inline void AckPostParcelDescription::set_pdid(const ::std::string& value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void AckPostParcelDescription::set_pdid(const char* value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void AckPostParcelDescription::set_pdid(const char* value, size_t size) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPostParcelDescription::mutable_pdid() {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  return pdid_;
}
inline ::std::string* AckPostParcelDescription::release_pdid() {
  clear_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pdid_;
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPostParcelDescription::set_allocated_pdid(::std::string* pdid) {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    delete pdid_;
  }
  if (pdid) {
    set_has_pdid();
    pdid_ = pdid;
  } else {
    clear_has_pdid();
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestParcelDescriptions

// required uint32 seqno = 1;
inline bool RequestParcelDescriptions::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestParcelDescriptions::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestParcelDescriptions::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestParcelDescriptions::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestParcelDescriptions::seqno() const {
  return seqno_;
}
inline void RequestParcelDescriptions::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional string pdid = 2;
inline bool RequestParcelDescriptions::has_pdid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestParcelDescriptions::set_has_pdid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestParcelDescriptions::clear_has_pdid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestParcelDescriptions::clear_pdid() {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    pdid_->clear();
  }
  clear_has_pdid();
}
inline const ::std::string& RequestParcelDescriptions::pdid() const {
  return *pdid_;
}
inline void RequestParcelDescriptions::set_pdid(const ::std::string& value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void RequestParcelDescriptions::set_pdid(const char* value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void RequestParcelDescriptions::set_pdid(const char* value, size_t size) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestParcelDescriptions::mutable_pdid() {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  return pdid_;
}
inline ::std::string* RequestParcelDescriptions::release_pdid() {
  clear_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pdid_;
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestParcelDescriptions::set_allocated_pdid(::std::string* pdid) {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    delete pdid_;
  }
  if (pdid) {
    set_has_pdid();
    pdid_ = pdid;
  } else {
    clear_has_pdid();
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .das.proto.Coordinate coordinate = 3;
inline bool RequestParcelDescriptions::has_coordinate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestParcelDescriptions::set_has_coordinate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestParcelDescriptions::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestParcelDescriptions::clear_coordinate() {
  if (coordinate_ != NULL) coordinate_->::das::proto::Coordinate::Clear();
  clear_has_coordinate();
}
inline const ::das::proto::Coordinate& RequestParcelDescriptions::coordinate() const {
  return coordinate_ != NULL ? *coordinate_ : *default_instance_->coordinate_;
}
inline ::das::proto::Coordinate* RequestParcelDescriptions::mutable_coordinate() {
  set_has_coordinate();
  if (coordinate_ == NULL) coordinate_ = new ::das::proto::Coordinate;
  return coordinate_;
}
inline ::das::proto::Coordinate* RequestParcelDescriptions::release_coordinate() {
  clear_has_coordinate();
  ::das::proto::Coordinate* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline void RequestParcelDescriptions::set_allocated_coordinate(::das::proto::Coordinate* coordinate) {
  delete coordinate_;
  coordinate_ = coordinate;
  if (coordinate) {
    set_has_coordinate();
  } else {
    clear_has_coordinate();
  }
}

// optional string surveryorname = 4;
inline bool RequestParcelDescriptions::has_surveryorname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestParcelDescriptions::set_has_surveryorname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestParcelDescriptions::clear_has_surveryorname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestParcelDescriptions::clear_surveryorname() {
  if (surveryorname_ != &::google::protobuf::internal::kEmptyString) {
    surveryorname_->clear();
  }
  clear_has_surveryorname();
}
inline const ::std::string& RequestParcelDescriptions::surveryorname() const {
  return *surveryorname_;
}
inline void RequestParcelDescriptions::set_surveryorname(const ::std::string& value) {
  set_has_surveryorname();
  if (surveryorname_ == &::google::protobuf::internal::kEmptyString) {
    surveryorname_ = new ::std::string;
  }
  surveryorname_->assign(value);
}
inline void RequestParcelDescriptions::set_surveryorname(const char* value) {
  set_has_surveryorname();
  if (surveryorname_ == &::google::protobuf::internal::kEmptyString) {
    surveryorname_ = new ::std::string;
  }
  surveryorname_->assign(value);
}
inline void RequestParcelDescriptions::set_surveryorname(const char* value, size_t size) {
  set_has_surveryorname();
  if (surveryorname_ == &::google::protobuf::internal::kEmptyString) {
    surveryorname_ = new ::std::string;
  }
  surveryorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestParcelDescriptions::mutable_surveryorname() {
  set_has_surveryorname();
  if (surveryorname_ == &::google::protobuf::internal::kEmptyString) {
    surveryorname_ = new ::std::string;
  }
  return surveryorname_;
}
inline ::std::string* RequestParcelDescriptions::release_surveryorname() {
  clear_has_surveryorname();
  if (surveryorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = surveryorname_;
    surveryorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestParcelDescriptions::set_allocated_surveryorname(::std::string* surveryorname) {
  if (surveryorname_ != &::google::protobuf::internal::kEmptyString) {
    delete surveryorname_;
  }
  if (surveryorname) {
    set_has_surveryorname();
    surveryorname_ = surveryorname;
  } else {
    clear_has_surveryorname();
    surveryorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string surveryorid = 5;
inline bool RequestParcelDescriptions::has_surveryorid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestParcelDescriptions::set_has_surveryorid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestParcelDescriptions::clear_has_surveryorid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestParcelDescriptions::clear_surveryorid() {
  if (surveryorid_ != &::google::protobuf::internal::kEmptyString) {
    surveryorid_->clear();
  }
  clear_has_surveryorid();
}
inline const ::std::string& RequestParcelDescriptions::surveryorid() const {
  return *surveryorid_;
}
inline void RequestParcelDescriptions::set_surveryorid(const ::std::string& value) {
  set_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    surveryorid_ = new ::std::string;
  }
  surveryorid_->assign(value);
}
inline void RequestParcelDescriptions::set_surveryorid(const char* value) {
  set_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    surveryorid_ = new ::std::string;
  }
  surveryorid_->assign(value);
}
inline void RequestParcelDescriptions::set_surveryorid(const char* value, size_t size) {
  set_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    surveryorid_ = new ::std::string;
  }
  surveryorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestParcelDescriptions::mutable_surveryorid() {
  set_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    surveryorid_ = new ::std::string;
  }
  return surveryorid_;
}
inline ::std::string* RequestParcelDescriptions::release_surveryorid() {
  clear_has_surveryorid();
  if (surveryorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = surveryorid_;
    surveryorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestParcelDescriptions::set_allocated_surveryorid(::std::string* surveryorid) {
  if (surveryorid_ != &::google::protobuf::internal::kEmptyString) {
    delete surveryorid_;
  }
  if (surveryorid) {
    set_has_surveryorid();
    surveryorid_ = surveryorid;
  } else {
    clear_has_surveryorid();
    surveryorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string registername = 6;
inline bool RequestParcelDescriptions::has_registername() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestParcelDescriptions::set_has_registername() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestParcelDescriptions::clear_has_registername() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestParcelDescriptions::clear_registername() {
  if (registername_ != &::google::protobuf::internal::kEmptyString) {
    registername_->clear();
  }
  clear_has_registername();
}
inline const ::std::string& RequestParcelDescriptions::registername() const {
  return *registername_;
}
inline void RequestParcelDescriptions::set_registername(const ::std::string& value) {
  set_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    registername_ = new ::std::string;
  }
  registername_->assign(value);
}
inline void RequestParcelDescriptions::set_registername(const char* value) {
  set_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    registername_ = new ::std::string;
  }
  registername_->assign(value);
}
inline void RequestParcelDescriptions::set_registername(const char* value, size_t size) {
  set_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    registername_ = new ::std::string;
  }
  registername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestParcelDescriptions::mutable_registername() {
  set_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    registername_ = new ::std::string;
  }
  return registername_;
}
inline ::std::string* RequestParcelDescriptions::release_registername() {
  clear_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = registername_;
    registername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestParcelDescriptions::set_allocated_registername(::std::string* registername) {
  if (registername_ != &::google::protobuf::internal::kEmptyString) {
    delete registername_;
  }
  if (registername) {
    set_has_registername();
    registername_ = registername;
  } else {
    clear_has_registername();
    registername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string registerid = 7;
inline bool RequestParcelDescriptions::has_registerid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestParcelDescriptions::set_has_registerid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestParcelDescriptions::clear_has_registerid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestParcelDescriptions::clear_registerid() {
  if (registerid_ != &::google::protobuf::internal::kEmptyString) {
    registerid_->clear();
  }
  clear_has_registerid();
}
inline const ::std::string& RequestParcelDescriptions::registerid() const {
  return *registerid_;
}
inline void RequestParcelDescriptions::set_registerid(const ::std::string& value) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(value);
}
inline void RequestParcelDescriptions::set_registerid(const char* value) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(value);
}
inline void RequestParcelDescriptions::set_registerid(const char* value, size_t size) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestParcelDescriptions::mutable_registerid() {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  return registerid_;
}
inline ::std::string* RequestParcelDescriptions::release_registerid() {
  clear_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = registerid_;
    registerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestParcelDescriptions::set_allocated_registerid(::std::string* registerid) {
  if (registerid_ != &::google::protobuf::internal::kEmptyString) {
    delete registerid_;
  }
  if (registerid) {
    set_has_registerid();
    registerid_ = registerid;
  } else {
    clear_has_registerid();
    registerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string parcelname = 8;
inline bool RequestParcelDescriptions::has_parcelname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestParcelDescriptions::set_has_parcelname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestParcelDescriptions::clear_has_parcelname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestParcelDescriptions::clear_parcelname() {
  if (parcelname_ != &::google::protobuf::internal::kEmptyString) {
    parcelname_->clear();
  }
  clear_has_parcelname();
}
inline const ::std::string& RequestParcelDescriptions::parcelname() const {
  return *parcelname_;
}
inline void RequestParcelDescriptions::set_parcelname(const ::std::string& value) {
  set_has_parcelname();
  if (parcelname_ == &::google::protobuf::internal::kEmptyString) {
    parcelname_ = new ::std::string;
  }
  parcelname_->assign(value);
}
inline void RequestParcelDescriptions::set_parcelname(const char* value) {
  set_has_parcelname();
  if (parcelname_ == &::google::protobuf::internal::kEmptyString) {
    parcelname_ = new ::std::string;
  }
  parcelname_->assign(value);
}
inline void RequestParcelDescriptions::set_parcelname(const char* value, size_t size) {
  set_has_parcelname();
  if (parcelname_ == &::google::protobuf::internal::kEmptyString) {
    parcelname_ = new ::std::string;
  }
  parcelname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestParcelDescriptions::mutable_parcelname() {
  set_has_parcelname();
  if (parcelname_ == &::google::protobuf::internal::kEmptyString) {
    parcelname_ = new ::std::string;
  }
  return parcelname_;
}
inline ::std::string* RequestParcelDescriptions::release_parcelname() {
  clear_has_parcelname();
  if (parcelname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parcelname_;
    parcelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestParcelDescriptions::set_allocated_parcelname(::std::string* parcelname) {
  if (parcelname_ != &::google::protobuf::internal::kEmptyString) {
    delete parcelname_;
  }
  if (parcelname) {
    set_has_parcelname();
    parcelname_ = parcelname;
  } else {
    clear_has_parcelname();
    parcelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string contracter = 9;
inline bool RequestParcelDescriptions::has_contracter() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestParcelDescriptions::set_has_contracter() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestParcelDescriptions::clear_has_contracter() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestParcelDescriptions::clear_contracter() {
  if (contracter_ != &::google::protobuf::internal::kEmptyString) {
    contracter_->clear();
  }
  clear_has_contracter();
}
inline const ::std::string& RequestParcelDescriptions::contracter() const {
  return *contracter_;
}
inline void RequestParcelDescriptions::set_contracter(const ::std::string& value) {
  set_has_contracter();
  if (contracter_ == &::google::protobuf::internal::kEmptyString) {
    contracter_ = new ::std::string;
  }
  contracter_->assign(value);
}
inline void RequestParcelDescriptions::set_contracter(const char* value) {
  set_has_contracter();
  if (contracter_ == &::google::protobuf::internal::kEmptyString) {
    contracter_ = new ::std::string;
  }
  contracter_->assign(value);
}
inline void RequestParcelDescriptions::set_contracter(const char* value, size_t size) {
  set_has_contracter();
  if (contracter_ == &::google::protobuf::internal::kEmptyString) {
    contracter_ = new ::std::string;
  }
  contracter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestParcelDescriptions::mutable_contracter() {
  set_has_contracter();
  if (contracter_ == &::google::protobuf::internal::kEmptyString) {
    contracter_ = new ::std::string;
  }
  return contracter_;
}
inline ::std::string* RequestParcelDescriptions::release_contracter() {
  clear_has_contracter();
  if (contracter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contracter_;
    contracter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestParcelDescriptions::set_allocated_contracter(::std::string* contracter) {
  if (contracter_ != &::google::protobuf::internal::kEmptyString) {
    delete contracter_;
  }
  if (contracter) {
    set_has_contracter();
    contracter_ = contracter;
  } else {
    clear_has_contracter();
    contracter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobileno = 10;
inline bool RequestParcelDescriptions::has_mobileno() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RequestParcelDescriptions::set_has_mobileno() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RequestParcelDescriptions::clear_has_mobileno() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RequestParcelDescriptions::clear_mobileno() {
  if (mobileno_ != &::google::protobuf::internal::kEmptyString) {
    mobileno_->clear();
  }
  clear_has_mobileno();
}
inline const ::std::string& RequestParcelDescriptions::mobileno() const {
  return *mobileno_;
}
inline void RequestParcelDescriptions::set_mobileno(const ::std::string& value) {
  set_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    mobileno_ = new ::std::string;
  }
  mobileno_->assign(value);
}
inline void RequestParcelDescriptions::set_mobileno(const char* value) {
  set_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    mobileno_ = new ::std::string;
  }
  mobileno_->assign(value);
}
inline void RequestParcelDescriptions::set_mobileno(const char* value, size_t size) {
  set_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    mobileno_ = new ::std::string;
  }
  mobileno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestParcelDescriptions::mutable_mobileno() {
  set_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    mobileno_ = new ::std::string;
  }
  return mobileno_;
}
inline ::std::string* RequestParcelDescriptions::release_mobileno() {
  clear_has_mobileno();
  if (mobileno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobileno_;
    mobileno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestParcelDescriptions::set_allocated_mobileno(::std::string* mobileno) {
  if (mobileno_ != &::google::protobuf::internal::kEmptyString) {
    delete mobileno_;
  }
  if (mobileno) {
    set_has_mobileno();
    mobileno_ = mobileno;
  } else {
    clear_has_mobileno();
    mobileno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .das.proto.Coordinate zones = 11;
inline int RequestParcelDescriptions::zones_size() const {
  return zones_.size();
}
inline void RequestParcelDescriptions::clear_zones() {
  zones_.Clear();
}
inline const ::das::proto::Coordinate& RequestParcelDescriptions::zones(int index) const {
  return zones_.Get(index);
}
inline ::das::proto::Coordinate* RequestParcelDescriptions::mutable_zones(int index) {
  return zones_.Mutable(index);
}
inline ::das::proto::Coordinate* RequestParcelDescriptions::add_zones() {
  return zones_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate >&
RequestParcelDescriptions::zones() const {
  return zones_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::Coordinate >*
RequestParcelDescriptions::mutable_zones() {
  return &zones_;
}

// -------------------------------------------------------------------

// AckRequestParcelDescriptions

// required uint32 seqno = 1;
inline bool AckRequestParcelDescriptions::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRequestParcelDescriptions::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRequestParcelDescriptions::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRequestParcelDescriptions::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckRequestParcelDescriptions::seqno() const {
  return seqno_;
}
inline void AckRequestParcelDescriptions::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckRequestParcelDescriptions::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRequestParcelDescriptions::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRequestParcelDescriptions::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRequestParcelDescriptions::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckRequestParcelDescriptions::result() const {
  return result_;
}
inline void AckRequestParcelDescriptions::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated .das.proto.ParcelDescription pds = 3;
inline int AckRequestParcelDescriptions::pds_size() const {
  return pds_.size();
}
inline void AckRequestParcelDescriptions::clear_pds() {
  pds_.Clear();
}
inline const ::das::proto::ParcelDescription& AckRequestParcelDescriptions::pds(int index) const {
  return pds_.Get(index);
}
inline ::das::proto::ParcelDescription* AckRequestParcelDescriptions::mutable_pds(int index) {
  return pds_.Mutable(index);
}
inline ::das::proto::ParcelDescription* AckRequestParcelDescriptions::add_pds() {
  return pds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelDescription >&
AckRequestParcelDescriptions::pds() const {
  return pds_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::ParcelDescription >*
AckRequestParcelDescriptions::mutable_pds() {
  return &pds_;
}

// -------------------------------------------------------------------

// DeleteParcelDescription

// required uint32 seqno = 1;
inline bool DeleteParcelDescription::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteParcelDescription::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteParcelDescription::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteParcelDescription::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 DeleteParcelDescription::seqno() const {
  return seqno_;
}
inline void DeleteParcelDescription::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string pdid = 2;
inline bool DeleteParcelDescription::has_pdid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteParcelDescription::set_has_pdid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteParcelDescription::clear_has_pdid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteParcelDescription::clear_pdid() {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    pdid_->clear();
  }
  clear_has_pdid();
}
inline const ::std::string& DeleteParcelDescription::pdid() const {
  return *pdid_;
}
inline void DeleteParcelDescription::set_pdid(const ::std::string& value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void DeleteParcelDescription::set_pdid(const char* value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void DeleteParcelDescription::set_pdid(const char* value, size_t size) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteParcelDescription::mutable_pdid() {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  return pdid_;
}
inline ::std::string* DeleteParcelDescription::release_pdid() {
  clear_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pdid_;
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeleteParcelDescription::set_allocated_pdid(::std::string* pdid) {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    delete pdid_;
  }
  if (pdid) {
    set_has_pdid();
    pdid_ = pdid;
  } else {
    clear_has_pdid();
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool delpsi = 3;
inline bool DeleteParcelDescription::has_delpsi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteParcelDescription::set_has_delpsi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteParcelDescription::clear_has_delpsi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteParcelDescription::clear_delpsi() {
  delpsi_ = false;
  clear_has_delpsi();
}
inline bool DeleteParcelDescription::delpsi() const {
  return delpsi_;
}
inline void DeleteParcelDescription::set_delpsi(bool value) {
  set_has_delpsi();
  delpsi_ = value;
}

// optional bool delpc = 4;
inline bool DeleteParcelDescription::has_delpc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeleteParcelDescription::set_has_delpc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeleteParcelDescription::clear_has_delpc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeleteParcelDescription::clear_delpc() {
  delpc_ = false;
  clear_has_delpc();
}
inline bool DeleteParcelDescription::delpc() const {
  return delpc_;
}
inline void DeleteParcelDescription::set_delpc(bool value) {
  set_has_delpc();
  delpc_ = value;
}

// -------------------------------------------------------------------

// AckDeleteParcelDescription

// required uint32 seqno = 1;
inline bool AckDeleteParcelDescription::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckDeleteParcelDescription::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckDeleteParcelDescription::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckDeleteParcelDescription::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckDeleteParcelDescription::seqno() const {
  return seqno_;
}
inline void AckDeleteParcelDescription::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckDeleteParcelDescription::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckDeleteParcelDescription::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckDeleteParcelDescription::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckDeleteParcelDescription::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckDeleteParcelDescription::result() const {
  return result_;
}
inline void AckDeleteParcelDescription::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SingleShrink

// required int32 bdr = 1;
inline bool SingleShrink::has_bdr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleShrink::set_has_bdr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleShrink::clear_has_bdr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleShrink::clear_bdr() {
  bdr_ = 0;
  clear_has_bdr();
}
inline ::google::protobuf::int32 SingleShrink::bdr() const {
  return bdr_;
}
inline void SingleShrink::set_bdr(::google::protobuf::int32 value) {
  set_has_bdr();
  bdr_ = value;
}

// required double safe = 2;
inline bool SingleShrink::has_safe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleShrink::set_has_safe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleShrink::clear_has_safe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleShrink::clear_safe() {
  safe_ = 0;
  clear_has_safe();
}
inline double SingleShrink::safe() const {
  return safe_;
}
inline void SingleShrink::set_safe(double value) {
  set_has_safe();
  safe_ = value;
}

// -------------------------------------------------------------------

// OperationPlan

// required double width = 1;
inline bool OperationPlan::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationPlan::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationPlan::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationPlan::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double OperationPlan::width() const {
  return width_;
}
inline void OperationPlan::set_width(double value) {
  set_has_width();
  width_ = value;
}

// required float angle = 2;
inline bool OperationPlan::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationPlan::set_has_angle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationPlan::clear_has_angle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationPlan::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float OperationPlan::angle() const {
  return angle_;
}
inline void OperationPlan::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// required bool anti = 3;
inline bool OperationPlan::has_anti() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationPlan::set_has_anti() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationPlan::clear_has_anti() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationPlan::clear_anti() {
  anti_ = false;
  clear_has_anti();
}
inline bool OperationPlan::anti() const {
  return anti_;
}
inline void OperationPlan::set_anti(bool value) {
  set_has_anti();
  anti_ = value;
}

// required bool single = 4;
inline bool OperationPlan::has_single() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationPlan::set_has_single() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationPlan::clear_has_single() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationPlan::clear_single() {
  single_ = false;
  clear_has_single();
}
inline bool OperationPlan::single() const {
  return single_;
}
inline void OperationPlan::set_single(bool value) {
  set_has_single();
  single_ = value;
}

// repeated .das.proto.SingleShrink bdrsafe = 5;
inline int OperationPlan::bdrsafe_size() const {
  return bdrsafe_.size();
}
inline void OperationPlan::clear_bdrsafe() {
  bdrsafe_.Clear();
}
inline const ::das::proto::SingleShrink& OperationPlan::bdrsafe(int index) const {
  return bdrsafe_.Get(index);
}
inline ::das::proto::SingleShrink* OperationPlan::mutable_bdrsafe(int index) {
  return bdrsafe_.Mutable(index);
}
inline ::das::proto::SingleShrink* OperationPlan::add_bdrsafe() {
  return bdrsafe_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::SingleShrink >&
OperationPlan::bdrsafe() const {
  return bdrsafe_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::SingleShrink >*
OperationPlan::mutable_bdrsafe() {
  return &bdrsafe_;
}

// required double block = 6;
inline bool OperationPlan::has_block() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperationPlan::set_has_block() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperationPlan::clear_has_block() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperationPlan::clear_block() {
  block_ = 0;
  clear_has_block();
}
inline double OperationPlan::block() const {
  return block_;
}
inline void OperationPlan::set_block(double value) {
  set_has_block();
  block_ = value;
}

// -------------------------------------------------------------------

// OperationDescription

// required string registerid = 1;
inline bool OperationDescription::has_registerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationDescription::set_has_registerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationDescription::clear_has_registerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationDescription::clear_registerid() {
  if (registerid_ != &::google::protobuf::internal::kEmptyString) {
    registerid_->clear();
  }
  clear_has_registerid();
}
inline const ::std::string& OperationDescription::registerid() const {
  return *registerid_;
}
inline void OperationDescription::set_registerid(const ::std::string& value) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(value);
}
inline void OperationDescription::set_registerid(const char* value) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(value);
}
inline void OperationDescription::set_registerid(const char* value, size_t size) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationDescription::mutable_registerid() {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  return registerid_;
}
inline ::std::string* OperationDescription::release_registerid() {
  clear_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = registerid_;
    registerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationDescription::set_allocated_registerid(::std::string* registerid) {
  if (registerid_ != &::google::protobuf::internal::kEmptyString) {
    delete registerid_;
  }
  if (registerid) {
    set_has_registerid();
    registerid_ = registerid;
  } else {
    clear_has_registerid();
    registerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pdid = 2;
inline bool OperationDescription::has_pdid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationDescription::set_has_pdid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationDescription::clear_has_pdid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationDescription::clear_pdid() {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    pdid_->clear();
  }
  clear_has_pdid();
}
inline const ::std::string& OperationDescription::pdid() const {
  return *pdid_;
}
inline void OperationDescription::set_pdid(const ::std::string& value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void OperationDescription::set_pdid(const char* value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void OperationDescription::set_pdid(const char* value, size_t size) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationDescription::mutable_pdid() {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  return pdid_;
}
inline ::std::string* OperationDescription::release_pdid() {
  clear_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pdid_;
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationDescription::set_allocated_pdid(::std::string* pdid) {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    delete pdid_;
  }
  if (pdid) {
    set_has_pdid();
    pdid_ = pdid;
  } else {
    clear_has_pdid();
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .das.proto.OperationPlan op = 3;
inline bool OperationDescription::has_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationDescription::set_has_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationDescription::clear_has_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationDescription::clear_op() {
  if (op_ != NULL) op_->::das::proto::OperationPlan::Clear();
  clear_has_op();
}
inline const ::das::proto::OperationPlan& OperationDescription::op() const {
  return op_ != NULL ? *op_ : *default_instance_->op_;
}
inline ::das::proto::OperationPlan* OperationDescription::mutable_op() {
  set_has_op();
  if (op_ == NULL) op_ = new ::das::proto::OperationPlan;
  return op_;
}
inline ::das::proto::OperationPlan* OperationDescription::release_op() {
  clear_has_op();
  ::das::proto::OperationPlan* temp = op_;
  op_ = NULL;
  return temp;
}
inline void OperationDescription::set_allocated_op(::das::proto::OperationPlan* op) {
  delete op_;
  op_ = op;
  if (op) {
    set_has_op();
  } else {
    clear_has_op();
  }
}

// required string crop = 4;
inline bool OperationDescription::has_crop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationDescription::set_has_crop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationDescription::clear_has_crop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationDescription::clear_crop() {
  if (crop_ != &::google::protobuf::internal::kEmptyString) {
    crop_->clear();
  }
  clear_has_crop();
}
inline const ::std::string& OperationDescription::crop() const {
  return *crop_;
}
inline void OperationDescription::set_crop(const ::std::string& value) {
  set_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    crop_ = new ::std::string;
  }
  crop_->assign(value);
}
inline void OperationDescription::set_crop(const char* value) {
  set_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    crop_ = new ::std::string;
  }
  crop_->assign(value);
}
inline void OperationDescription::set_crop(const char* value, size_t size) {
  set_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    crop_ = new ::std::string;
  }
  crop_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationDescription::mutable_crop() {
  set_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    crop_ = new ::std::string;
  }
  return crop_;
}
inline ::std::string* OperationDescription::release_crop() {
  clear_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crop_;
    crop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationDescription::set_allocated_crop(::std::string* crop) {
  if (crop_ != &::google::protobuf::internal::kEmptyString) {
    delete crop_;
  }
  if (crop) {
    set_has_crop();
    crop_ = crop;
  } else {
    clear_has_crop();
    crop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string drug = 5;
inline bool OperationDescription::has_drug() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationDescription::set_has_drug() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationDescription::clear_has_drug() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationDescription::clear_drug() {
  if (drug_ != &::google::protobuf::internal::kEmptyString) {
    drug_->clear();
  }
  clear_has_drug();
}
inline const ::std::string& OperationDescription::drug() const {
  return *drug_;
}
inline void OperationDescription::set_drug(const ::std::string& value) {
  set_has_drug();
  if (drug_ == &::google::protobuf::internal::kEmptyString) {
    drug_ = new ::std::string;
  }
  drug_->assign(value);
}
inline void OperationDescription::set_drug(const char* value) {
  set_has_drug();
  if (drug_ == &::google::protobuf::internal::kEmptyString) {
    drug_ = new ::std::string;
  }
  drug_->assign(value);
}
inline void OperationDescription::set_drug(const char* value, size_t size) {
  set_has_drug();
  if (drug_ == &::google::protobuf::internal::kEmptyString) {
    drug_ = new ::std::string;
  }
  drug_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationDescription::mutable_drug() {
  set_has_drug();
  if (drug_ == &::google::protobuf::internal::kEmptyString) {
    drug_ = new ::std::string;
  }
  return drug_;
}
inline ::std::string* OperationDescription::release_drug() {
  clear_has_drug();
  if (drug_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = drug_;
    drug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationDescription::set_allocated_drug(::std::string* drug) {
  if (drug_ != &::google::protobuf::internal::kEmptyString) {
    delete drug_;
  }
  if (drug) {
    set_has_drug();
    drug_ = drug;
  } else {
    clear_has_drug();
    drug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float prize = 6;
inline bool OperationDescription::has_prize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperationDescription::set_has_prize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperationDescription::clear_has_prize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperationDescription::clear_prize() {
  prize_ = 0;
  clear_has_prize();
}
inline float OperationDescription::prize() const {
  return prize_;
}
inline void OperationDescription::set_prize(float value) {
  set_has_prize();
  prize_ = value;
}

// optional uint64 plantime = 7;
inline bool OperationDescription::has_plantime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OperationDescription::set_has_plantime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OperationDescription::clear_has_plantime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OperationDescription::clear_plantime() {
  plantime_ = GOOGLE_ULONGLONG(0);
  clear_has_plantime();
}
inline ::google::protobuf::uint64 OperationDescription::plantime() const {
  return plantime_;
}
inline void OperationDescription::set_plantime(::google::protobuf::uint64 value) {
  set_has_plantime();
  plantime_ = value;
}

// optional string notes = 8;
inline bool OperationDescription::has_notes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OperationDescription::set_has_notes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OperationDescription::clear_has_notes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OperationDescription::clear_notes() {
  if (notes_ != &::google::protobuf::internal::kEmptyString) {
    notes_->clear();
  }
  clear_has_notes();
}
inline const ::std::string& OperationDescription::notes() const {
  return *notes_;
}
inline void OperationDescription::set_notes(const ::std::string& value) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(value);
}
inline void OperationDescription::set_notes(const char* value) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(value);
}
inline void OperationDescription::set_notes(const char* value, size_t size) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationDescription::mutable_notes() {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  return notes_;
}
inline ::std::string* OperationDescription::release_notes() {
  clear_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notes_;
    notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationDescription::set_allocated_notes(::std::string* notes) {
  if (notes_ != &::google::protobuf::internal::kEmptyString) {
    delete notes_;
  }
  if (notes) {
    set_has_notes();
    notes_ = notes;
  } else {
    clear_has_notes();
    notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string odid = 9;
inline bool OperationDescription::has_odid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OperationDescription::set_has_odid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OperationDescription::clear_has_odid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OperationDescription::clear_odid() {
  if (odid_ != &::google::protobuf::internal::kEmptyString) {
    odid_->clear();
  }
  clear_has_odid();
}
inline const ::std::string& OperationDescription::odid() const {
  return *odid_;
}
inline void OperationDescription::set_odid(const ::std::string& value) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(value);
}
inline void OperationDescription::set_odid(const char* value) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(value);
}
inline void OperationDescription::set_odid(const char* value, size_t size) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationDescription::mutable_odid() {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  return odid_;
}
inline ::std::string* OperationDescription::release_odid() {
  clear_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = odid_;
    odid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationDescription::set_allocated_odid(::std::string* odid) {
  if (odid_ != &::google::protobuf::internal::kEmptyString) {
    delete odid_;
  }
  if (odid) {
    set_has_odid();
    odid_ = odid;
  } else {
    clear_has_odid();
    odid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostOperationDescription

// required uint32 seqno = 1;
inline bool PostOperationDescription::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostOperationDescription::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostOperationDescription::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostOperationDescription::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostOperationDescription::seqno() const {
  return seqno_;
}
inline void PostOperationDescription::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required .das.proto.OperationDescription od = 2;
inline bool PostOperationDescription::has_od() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostOperationDescription::set_has_od() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostOperationDescription::clear_has_od() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostOperationDescription::clear_od() {
  if (od_ != NULL) od_->::das::proto::OperationDescription::Clear();
  clear_has_od();
}
inline const ::das::proto::OperationDescription& PostOperationDescription::od() const {
  return od_ != NULL ? *od_ : *default_instance_->od_;
}
inline ::das::proto::OperationDescription* PostOperationDescription::mutable_od() {
  set_has_od();
  if (od_ == NULL) od_ = new ::das::proto::OperationDescription;
  return od_;
}
inline ::das::proto::OperationDescription* PostOperationDescription::release_od() {
  clear_has_od();
  ::das::proto::OperationDescription* temp = od_;
  od_ = NULL;
  return temp;
}
inline void PostOperationDescription::set_allocated_od(::das::proto::OperationDescription* od) {
  delete od_;
  od_ = od;
  if (od) {
    set_has_od();
  } else {
    clear_has_od();
  }
}

// -------------------------------------------------------------------

// AckPostOperationDescription

// required uint32 seqno = 1;
inline bool AckPostOperationDescription::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostOperationDescription::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostOperationDescription::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostOperationDescription::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostOperationDescription::seqno() const {
  return seqno_;
}
inline void AckPostOperationDescription::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPostOperationDescription::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostOperationDescription::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostOperationDescription::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostOperationDescription::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPostOperationDescription::result() const {
  return result_;
}
inline void AckPostOperationDescription::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string odid = 3;
inline bool AckPostOperationDescription::has_odid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckPostOperationDescription::set_has_odid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckPostOperationDescription::clear_has_odid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckPostOperationDescription::clear_odid() {
  if (odid_ != &::google::protobuf::internal::kEmptyString) {
    odid_->clear();
  }
  clear_has_odid();
}
inline const ::std::string& AckPostOperationDescription::odid() const {
  return *odid_;
}
inline void AckPostOperationDescription::set_odid(const ::std::string& value) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(value);
}
inline void AckPostOperationDescription::set_odid(const char* value) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(value);
}
inline void AckPostOperationDescription::set_odid(const char* value, size_t size) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPostOperationDescription::mutable_odid() {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  return odid_;
}
inline ::std::string* AckPostOperationDescription::release_odid() {
  clear_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = odid_;
    odid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPostOperationDescription::set_allocated_odid(::std::string* odid) {
  if (odid_ != &::google::protobuf::internal::kEmptyString) {
    delete odid_;
  }
  if (odid) {
    set_has_odid();
    odid_ = odid;
  } else {
    clear_has_odid();
    odid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestOperationDescriptions

// required uint32 seqno = 1;
inline bool RequestOperationDescriptions::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestOperationDescriptions::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestOperationDescriptions::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestOperationDescriptions::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestOperationDescriptions::seqno() const {
  return seqno_;
}
inline void RequestOperationDescriptions::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// optional string odid = 2;
inline bool RequestOperationDescriptions::has_odid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestOperationDescriptions::set_has_odid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestOperationDescriptions::clear_has_odid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestOperationDescriptions::clear_odid() {
  if (odid_ != &::google::protobuf::internal::kEmptyString) {
    odid_->clear();
  }
  clear_has_odid();
}
inline const ::std::string& RequestOperationDescriptions::odid() const {
  return *odid_;
}
inline void RequestOperationDescriptions::set_odid(const ::std::string& value) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(value);
}
inline void RequestOperationDescriptions::set_odid(const char* value) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(value);
}
inline void RequestOperationDescriptions::set_odid(const char* value, size_t size) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestOperationDescriptions::mutable_odid() {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  return odid_;
}
inline ::std::string* RequestOperationDescriptions::release_odid() {
  clear_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = odid_;
    odid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestOperationDescriptions::set_allocated_odid(::std::string* odid) {
  if (odid_ != &::google::protobuf::internal::kEmptyString) {
    delete odid_;
  }
  if (odid) {
    set_has_odid();
    odid_ = odid;
  } else {
    clear_has_odid();
    odid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pdid = 3;
inline bool RequestOperationDescriptions::has_pdid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestOperationDescriptions::set_has_pdid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestOperationDescriptions::clear_has_pdid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestOperationDescriptions::clear_pdid() {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    pdid_->clear();
  }
  clear_has_pdid();
}
inline const ::std::string& RequestOperationDescriptions::pdid() const {
  return *pdid_;
}
inline void RequestOperationDescriptions::set_pdid(const ::std::string& value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void RequestOperationDescriptions::set_pdid(const char* value) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(value);
}
inline void RequestOperationDescriptions::set_pdid(const char* value, size_t size) {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  pdid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestOperationDescriptions::mutable_pdid() {
  set_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    pdid_ = new ::std::string;
  }
  return pdid_;
}
inline ::std::string* RequestOperationDescriptions::release_pdid() {
  clear_has_pdid();
  if (pdid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pdid_;
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestOperationDescriptions::set_allocated_pdid(::std::string* pdid) {
  if (pdid_ != &::google::protobuf::internal::kEmptyString) {
    delete pdid_;
  }
  if (pdid) {
    set_has_pdid();
    pdid_ = pdid;
  } else {
    clear_has_pdid();
    pdid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string registerid = 4;
inline bool RequestOperationDescriptions::has_registerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestOperationDescriptions::set_has_registerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestOperationDescriptions::clear_has_registerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestOperationDescriptions::clear_registerid() {
  if (registerid_ != &::google::protobuf::internal::kEmptyString) {
    registerid_->clear();
  }
  clear_has_registerid();
}
inline const ::std::string& RequestOperationDescriptions::registerid() const {
  return *registerid_;
}
inline void RequestOperationDescriptions::set_registerid(const ::std::string& value) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(value);
}
inline void RequestOperationDescriptions::set_registerid(const char* value) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(value);
}
inline void RequestOperationDescriptions::set_registerid(const char* value, size_t size) {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  registerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestOperationDescriptions::mutable_registerid() {
  set_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    registerid_ = new ::std::string;
  }
  return registerid_;
}
inline ::std::string* RequestOperationDescriptions::release_registerid() {
  clear_has_registerid();
  if (registerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = registerid_;
    registerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestOperationDescriptions::set_allocated_registerid(::std::string* registerid) {
  if (registerid_ != &::google::protobuf::internal::kEmptyString) {
    delete registerid_;
  }
  if (registerid) {
    set_has_registerid();
    registerid_ = registerid;
  } else {
    clear_has_registerid();
    registerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckRequestOperationDescriptions

// required uint32 seqno = 1;
inline bool AckRequestOperationDescriptions::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRequestOperationDescriptions::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRequestOperationDescriptions::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRequestOperationDescriptions::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckRequestOperationDescriptions::seqno() const {
  return seqno_;
}
inline void AckRequestOperationDescriptions::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckRequestOperationDescriptions::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRequestOperationDescriptions::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRequestOperationDescriptions::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRequestOperationDescriptions::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckRequestOperationDescriptions::result() const {
  return result_;
}
inline void AckRequestOperationDescriptions::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated .das.proto.OperationDescription ods = 3;
inline int AckRequestOperationDescriptions::ods_size() const {
  return ods_.size();
}
inline void AckRequestOperationDescriptions::clear_ods() {
  ods_.Clear();
}
inline const ::das::proto::OperationDescription& AckRequestOperationDescriptions::ods(int index) const {
  return ods_.Get(index);
}
inline ::das::proto::OperationDescription* AckRequestOperationDescriptions::mutable_ods(int index) {
  return ods_.Mutable(index);
}
inline ::das::proto::OperationDescription* AckRequestOperationDescriptions::add_ods() {
  return ods_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::OperationDescription >&
AckRequestOperationDescriptions::ods() const {
  return ods_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::OperationDescription >*
AckRequestOperationDescriptions::mutable_ods() {
  return &ods_;
}

// -------------------------------------------------------------------

// DeleteOperationDescription

// required uint32 seqno = 1;
inline bool DeleteOperationDescription::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteOperationDescription::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteOperationDescription::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteOperationDescription::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 DeleteOperationDescription::seqno() const {
  return seqno_;
}
inline void DeleteOperationDescription::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string odid = 2;
inline bool DeleteOperationDescription::has_odid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteOperationDescription::set_has_odid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteOperationDescription::clear_has_odid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteOperationDescription::clear_odid() {
  if (odid_ != &::google::protobuf::internal::kEmptyString) {
    odid_->clear();
  }
  clear_has_odid();
}
inline const ::std::string& DeleteOperationDescription::odid() const {
  return *odid_;
}
inline void DeleteOperationDescription::set_odid(const ::std::string& value) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(value);
}
inline void DeleteOperationDescription::set_odid(const char* value) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(value);
}
inline void DeleteOperationDescription::set_odid(const char* value, size_t size) {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  odid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteOperationDescription::mutable_odid() {
  set_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    odid_ = new ::std::string;
  }
  return odid_;
}
inline ::std::string* DeleteOperationDescription::release_odid() {
  clear_has_odid();
  if (odid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = odid_;
    odid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeleteOperationDescription::set_allocated_odid(::std::string* odid) {
  if (odid_ != &::google::protobuf::internal::kEmptyString) {
    delete odid_;
  }
  if (odid) {
    set_has_odid();
    odid_ = odid;
  } else {
    clear_has_odid();
    odid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckDeleteOperationDescription

// required uint32 seqno = 1;
inline bool AckDeleteOperationDescription::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckDeleteOperationDescription::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckDeleteOperationDescription::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckDeleteOperationDescription::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckDeleteOperationDescription::seqno() const {
  return seqno_;
}
inline void AckDeleteOperationDescription::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckDeleteOperationDescription::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckDeleteOperationDescription::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckDeleteOperationDescription::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckDeleteOperationDescription::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckDeleteOperationDescription::result() const {
  return result_;
}
inline void AckDeleteOperationDescription::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// BillInformation

// optional float servicecharge = 1;
inline bool BillInformation::has_servicecharge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BillInformation::set_has_servicecharge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BillInformation::clear_has_servicecharge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BillInformation::clear_servicecharge() {
  servicecharge_ = 0;
  clear_has_servicecharge();
}
inline float BillInformation::servicecharge() const {
  return servicecharge_;
}
inline void BillInformation::set_servicecharge(float value) {
  set_has_servicecharge();
  servicecharge_ = value;
}

// optional float pesticidecharge = 2;
inline bool BillInformation::has_pesticidecharge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BillInformation::set_has_pesticidecharge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BillInformation::clear_has_pesticidecharge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BillInformation::clear_pesticidecharge() {
  pesticidecharge_ = 0;
  clear_has_pesticidecharge();
}
inline float BillInformation::pesticidecharge() const {
  return pesticidecharge_;
}
inline void BillInformation::set_pesticidecharge(float value) {
  set_has_pesticidecharge();
  pesticidecharge_ = value;
}

// optional float othercharge = 3;
inline bool BillInformation::has_othercharge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BillInformation::set_has_othercharge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BillInformation::clear_has_othercharge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BillInformation::clear_othercharge() {
  othercharge_ = 0;
  clear_has_othercharge();
}
inline float BillInformation::othercharge() const {
  return othercharge_;
}
inline void BillInformation::set_othercharge(float value) {
  set_has_othercharge();
  othercharge_ = value;
}

// required float sumcharge = 4;
inline bool BillInformation::has_sumcharge() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BillInformation::set_has_sumcharge() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BillInformation::clear_has_sumcharge() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BillInformation::clear_sumcharge() {
  sumcharge_ = 0;
  clear_has_sumcharge();
}
inline float BillInformation::sumcharge() const {
  return sumcharge_;
}
inline void BillInformation::set_sumcharge(float value) {
  set_has_sumcharge();
  sumcharge_ = value;
}

// required string pesticide = 5;
inline bool BillInformation::has_pesticide() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BillInformation::set_has_pesticide() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BillInformation::clear_has_pesticide() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BillInformation::clear_pesticide() {
  if (pesticide_ != &::google::protobuf::internal::kEmptyString) {
    pesticide_->clear();
  }
  clear_has_pesticide();
}
inline const ::std::string& BillInformation::pesticide() const {
  return *pesticide_;
}
inline void BillInformation::set_pesticide(const ::std::string& value) {
  set_has_pesticide();
  if (pesticide_ == &::google::protobuf::internal::kEmptyString) {
    pesticide_ = new ::std::string;
  }
  pesticide_->assign(value);
}
inline void BillInformation::set_pesticide(const char* value) {
  set_has_pesticide();
  if (pesticide_ == &::google::protobuf::internal::kEmptyString) {
    pesticide_ = new ::std::string;
  }
  pesticide_->assign(value);
}
inline void BillInformation::set_pesticide(const char* value, size_t size) {
  set_has_pesticide();
  if (pesticide_ == &::google::protobuf::internal::kEmptyString) {
    pesticide_ = new ::std::string;
  }
  pesticide_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillInformation::mutable_pesticide() {
  set_has_pesticide();
  if (pesticide_ == &::google::protobuf::internal::kEmptyString) {
    pesticide_ = new ::std::string;
  }
  return pesticide_;
}
inline ::std::string* BillInformation::release_pesticide() {
  clear_has_pesticide();
  if (pesticide_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pesticide_;
    pesticide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillInformation::set_allocated_pesticide(::std::string* pesticide) {
  if (pesticide_ != &::google::protobuf::internal::kEmptyString) {
    delete pesticide_;
  }
  if (pesticide) {
    set_has_pesticide();
    pesticide_ = pesticide;
  } else {
    clear_has_pesticide();
    pesticide_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string crop = 6;
inline bool BillInformation::has_crop() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BillInformation::set_has_crop() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BillInformation::clear_has_crop() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BillInformation::clear_crop() {
  if (crop_ != &::google::protobuf::internal::kEmptyString) {
    crop_->clear();
  }
  clear_has_crop();
}
inline const ::std::string& BillInformation::crop() const {
  return *crop_;
}
inline void BillInformation::set_crop(const ::std::string& value) {
  set_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    crop_ = new ::std::string;
  }
  crop_->assign(value);
}
inline void BillInformation::set_crop(const char* value) {
  set_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    crop_ = new ::std::string;
  }
  crop_->assign(value);
}
inline void BillInformation::set_crop(const char* value, size_t size) {
  set_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    crop_ = new ::std::string;
  }
  crop_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BillInformation::mutable_crop() {
  set_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    crop_ = new ::std::string;
  }
  return crop_;
}
inline ::std::string* BillInformation::release_crop() {
  clear_has_crop();
  if (crop_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crop_;
    crop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BillInformation::set_allocated_crop(::std::string* crop) {
  if (crop_ != &::google::protobuf::internal::kEmptyString) {
    delete crop_;
  }
  if (crop) {
    set_has_crop();
    crop_ = crop;
  } else {
    clear_has_crop();
    crop_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OperationRoute

// required string gsid = 1;
inline bool OperationRoute::has_gsid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationRoute::set_has_gsid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationRoute::clear_has_gsid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationRoute::clear_gsid() {
  if (gsid_ != &::google::protobuf::internal::kEmptyString) {
    gsid_->clear();
  }
  clear_has_gsid();
}
inline const ::std::string& OperationRoute::gsid() const {
  return *gsid_;
}
inline void OperationRoute::set_gsid(const ::std::string& value) {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  gsid_->assign(value);
}
inline void OperationRoute::set_gsid(const char* value) {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  gsid_->assign(value);
}
inline void OperationRoute::set_gsid(const char* value, size_t size) {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  gsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationRoute::mutable_gsid() {
  set_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    gsid_ = new ::std::string;
  }
  return gsid_;
}
inline ::std::string* OperationRoute::release_gsid() {
  clear_has_gsid();
  if (gsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gsid_;
    gsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationRoute::set_allocated_gsid(::std::string* gsid) {
  if (gsid_ != &::google::protobuf::internal::kEmptyString) {
    delete gsid_;
  }
  if (gsid) {
    set_has_gsid();
    gsid_ = gsid;
  } else {
    clear_has_gsid();
    gsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string uavid = 2;
inline bool OperationRoute::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationRoute::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationRoute::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationRoute::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& OperationRoute::uavid() const {
  return *uavid_;
}
inline void OperationRoute::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void OperationRoute::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void OperationRoute::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationRoute::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* OperationRoute::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationRoute::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string rpid = 3;
inline bool OperationRoute::has_rpid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationRoute::set_has_rpid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationRoute::clear_has_rpid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationRoute::clear_rpid() {
  if (rpid_ != &::google::protobuf::internal::kEmptyString) {
    rpid_->clear();
  }
  clear_has_rpid();
}
inline const ::std::string& OperationRoute::rpid() const {
  return *rpid_;
}
inline void OperationRoute::set_rpid(const ::std::string& value) {
  set_has_rpid();
  if (rpid_ == &::google::protobuf::internal::kEmptyString) {
    rpid_ = new ::std::string;
  }
  rpid_->assign(value);
}
inline void OperationRoute::set_rpid(const char* value) {
  set_has_rpid();
  if (rpid_ == &::google::protobuf::internal::kEmptyString) {
    rpid_ = new ::std::string;
  }
  rpid_->assign(value);
}
inline void OperationRoute::set_rpid(const char* value, size_t size) {
  set_has_rpid();
  if (rpid_ == &::google::protobuf::internal::kEmptyString) {
    rpid_ = new ::std::string;
  }
  rpid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationRoute::mutable_rpid() {
  set_has_rpid();
  if (rpid_ == &::google::protobuf::internal::kEmptyString) {
    rpid_ = new ::std::string;
  }
  return rpid_;
}
inline ::std::string* OperationRoute::release_rpid() {
  clear_has_rpid();
  if (rpid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rpid_;
    rpid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OperationRoute::set_allocated_rpid(::std::string* rpid) {
  if (rpid_ != &::google::protobuf::internal::kEmptyString) {
    delete rpid_;
  }
  if (rpid) {
    set_has_rpid();
    rpid_ = rpid;
  } else {
    clear_has_rpid();
    rpid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 createtime = 4;
inline bool OperationRoute::has_createtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationRoute::set_has_createtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationRoute::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationRoute::clear_createtime() {
  createtime_ = GOOGLE_ULONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::uint64 OperationRoute::createtime() const {
  return createtime_;
}
inline void OperationRoute::set_createtime(::google::protobuf::uint64 value) {
  set_has_createtime();
  createtime_ = value;
}

// required float maxvoyage = 5;
inline bool OperationRoute::has_maxvoyage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationRoute::set_has_maxvoyage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationRoute::clear_has_maxvoyage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationRoute::clear_maxvoyage() {
  maxvoyage_ = 0;
  clear_has_maxvoyage();
}
inline float OperationRoute::maxvoyage() const {
  return maxvoyage_;
}
inline void OperationRoute::set_maxvoyage(float value) {
  set_has_maxvoyage();
  maxvoyage_ = value;
}

// repeated bytes missions = 6;
inline int OperationRoute::missions_size() const {
  return missions_.size();
}
inline void OperationRoute::clear_missions() {
  missions_.Clear();
}
inline const ::std::string& OperationRoute::missions(int index) const {
  return missions_.Get(index);
}
inline ::std::string* OperationRoute::mutable_missions(int index) {
  return missions_.Mutable(index);
}
inline void OperationRoute::set_missions(int index, const ::std::string& value) {
  missions_.Mutable(index)->assign(value);
}
inline void OperationRoute::set_missions(int index, const char* value) {
  missions_.Mutable(index)->assign(value);
}
inline void OperationRoute::set_missions(int index, const void* value, size_t size) {
  missions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationRoute::add_missions() {
  return missions_.Add();
}
inline void OperationRoute::add_missions(const ::std::string& value) {
  missions_.Add()->assign(value);
}
inline void OperationRoute::add_missions(const char* value) {
  missions_.Add()->assign(value);
}
inline void OperationRoute::add_missions(const void* value, size_t size) {
  missions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperationRoute::missions() const {
  return missions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperationRoute::mutable_missions() {
  return &missions_;
}

// repeated bytes boundarys = 7;
inline int OperationRoute::boundarys_size() const {
  return boundarys_.size();
}
inline void OperationRoute::clear_boundarys() {
  boundarys_.Clear();
}
inline const ::std::string& OperationRoute::boundarys(int index) const {
  return boundarys_.Get(index);
}
inline ::std::string* OperationRoute::mutable_boundarys(int index) {
  return boundarys_.Mutable(index);
}
inline void OperationRoute::set_boundarys(int index, const ::std::string& value) {
  boundarys_.Mutable(index)->assign(value);
}
inline void OperationRoute::set_boundarys(int index, const char* value) {
  boundarys_.Mutable(index)->assign(value);
}
inline void OperationRoute::set_boundarys(int index, const void* value, size_t size) {
  boundarys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationRoute::add_boundarys() {
  return boundarys_.Add();
}
inline void OperationRoute::add_boundarys(const ::std::string& value) {
  boundarys_.Add()->assign(value);
}
inline void OperationRoute::add_boundarys(const char* value) {
  boundarys_.Add()->assign(value);
}
inline void OperationRoute::add_boundarys(const void* value, size_t size) {
  boundarys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperationRoute::boundarys() const {
  return boundarys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperationRoute::mutable_boundarys() {
  return &boundarys_;
}

// optional .das.proto.BillInformation bi = 8;
inline bool OperationRoute::has_bi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OperationRoute::set_has_bi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OperationRoute::clear_has_bi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OperationRoute::clear_bi() {
  if (bi_ != NULL) bi_->::das::proto::BillInformation::Clear();
  clear_has_bi();
}
inline const ::das::proto::BillInformation& OperationRoute::bi() const {
  return bi_ != NULL ? *bi_ : *default_instance_->bi_;
}
inline ::das::proto::BillInformation* OperationRoute::mutable_bi() {
  set_has_bi();
  if (bi_ == NULL) bi_ = new ::das::proto::BillInformation;
  return bi_;
}
inline ::das::proto::BillInformation* OperationRoute::release_bi() {
  clear_has_bi();
  ::das::proto::BillInformation* temp = bi_;
  bi_ = NULL;
  return temp;
}
inline void OperationRoute::set_allocated_bi(::das::proto::BillInformation* bi) {
  delete bi_;
  bi_ = bi;
  if (bi) {
    set_has_bi();
  } else {
    clear_has_bi();
  }
}

// -------------------------------------------------------------------

// PostOperationRoute

// required uint32 seqno = 1;
inline bool PostOperationRoute::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostOperationRoute::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostOperationRoute::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostOperationRoute::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostOperationRoute::seqno() const {
  return seqno_;
}
inline void PostOperationRoute::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required .das.proto.OperationRoute or = 2;
inline bool PostOperationRoute::has_or_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostOperationRoute::set_has_or_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostOperationRoute::clear_has_or_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostOperationRoute::clear_or_() {
  if (or__ != NULL) or__->::das::proto::OperationRoute::Clear();
  clear_has_or_();
}
inline const ::das::proto::OperationRoute& PostOperationRoute::or_() const {
  return or__ != NULL ? *or__ : *default_instance_->or__;
}
inline ::das::proto::OperationRoute* PostOperationRoute::mutable_or_() {
  set_has_or_();
  if (or__ == NULL) or__ = new ::das::proto::OperationRoute;
  return or__;
}
inline ::das::proto::OperationRoute* PostOperationRoute::release_or_() {
  clear_has_or_();
  ::das::proto::OperationRoute* temp = or__;
  or__ = NULL;
  return temp;
}
inline void PostOperationRoute::set_allocated_or_(::das::proto::OperationRoute* or_) {
  delete or__;
  or__ = or_;
  if (or_) {
    set_has_or_();
  } else {
    clear_has_or_();
  }
}

// -------------------------------------------------------------------

// AckPostOperationRoute

// required uint32 seqno = 1;
inline bool AckPostOperationRoute::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostOperationRoute::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostOperationRoute::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostOperationRoute::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostOperationRoute::seqno() const {
  return seqno_;
}
inline void AckPostOperationRoute::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPostOperationRoute::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostOperationRoute::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostOperationRoute::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostOperationRoute::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPostOperationRoute::result() const {
  return result_;
}
inline void AckPostOperationRoute::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// UploadOperationRoutes

// required uint32 seqno = 1;
inline bool UploadOperationRoutes::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadOperationRoutes::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadOperationRoutes::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadOperationRoutes::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 UploadOperationRoutes::seqno() const {
  return seqno_;
}
inline void UploadOperationRoutes::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string uavid = 2;
inline bool UploadOperationRoutes::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadOperationRoutes::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadOperationRoutes::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadOperationRoutes::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& UploadOperationRoutes::uavid() const {
  return *uavid_;
}
inline void UploadOperationRoutes::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void UploadOperationRoutes::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void UploadOperationRoutes::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UploadOperationRoutes::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* UploadOperationRoutes::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UploadOperationRoutes::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userid = 3;
inline bool UploadOperationRoutes::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UploadOperationRoutes::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UploadOperationRoutes::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UploadOperationRoutes::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& UploadOperationRoutes::userid() const {
  return *userid_;
}
inline void UploadOperationRoutes::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UploadOperationRoutes::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UploadOperationRoutes::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UploadOperationRoutes::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* UploadOperationRoutes::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UploadOperationRoutes::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 timestamp = 4;
inline bool UploadOperationRoutes::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UploadOperationRoutes::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UploadOperationRoutes::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UploadOperationRoutes::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 UploadOperationRoutes::timestamp() const {
  return timestamp_;
}
inline void UploadOperationRoutes::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required int32 countmission = 5;
inline bool UploadOperationRoutes::has_countmission() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UploadOperationRoutes::set_has_countmission() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UploadOperationRoutes::clear_has_countmission() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UploadOperationRoutes::clear_countmission() {
  countmission_ = 0;
  clear_has_countmission();
}
inline ::google::protobuf::int32 UploadOperationRoutes::countmission() const {
  return countmission_;
}
inline void UploadOperationRoutes::set_countmission(::google::protobuf::int32 value) {
  set_has_countmission();
  countmission_ = value;
}

// required int32 countboundary = 6;
inline bool UploadOperationRoutes::has_countboundary() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UploadOperationRoutes::set_has_countboundary() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UploadOperationRoutes::clear_has_countboundary() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UploadOperationRoutes::clear_countboundary() {
  countboundary_ = 0;
  clear_has_countboundary();
}
inline ::google::protobuf::int32 UploadOperationRoutes::countboundary() const {
  return countboundary_;
}
inline void UploadOperationRoutes::set_countboundary(::google::protobuf::int32 value) {
  set_has_countboundary();
  countboundary_ = value;
}

// -------------------------------------------------------------------

// SyscOperationRoutes

// required uint32 seqno = 1;
inline bool SyscOperationRoutes::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyscOperationRoutes::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyscOperationRoutes::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyscOperationRoutes::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 SyscOperationRoutes::seqno() const {
  return seqno_;
}
inline void SyscOperationRoutes::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool SyscOperationRoutes::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyscOperationRoutes::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyscOperationRoutes::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyscOperationRoutes::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 SyscOperationRoutes::result() const {
  return result_;
}
inline void SyscOperationRoutes::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string uavid = 3;
inline bool SyscOperationRoutes::has_uavid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyscOperationRoutes::set_has_uavid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyscOperationRoutes::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyscOperationRoutes::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& SyscOperationRoutes::uavid() const {
  return *uavid_;
}
inline void SyscOperationRoutes::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void SyscOperationRoutes::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void SyscOperationRoutes::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyscOperationRoutes::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* SyscOperationRoutes::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SyscOperationRoutes::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 index = 5;
inline bool SyscOperationRoutes::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyscOperationRoutes::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyscOperationRoutes::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyscOperationRoutes::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 SyscOperationRoutes::index() const {
  return index_;
}
inline void SyscOperationRoutes::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional int32 count = 6;
inline bool SyscOperationRoutes::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SyscOperationRoutes::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SyscOperationRoutes::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SyscOperationRoutes::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 SyscOperationRoutes::count() const {
  return count_;
}
inline void SyscOperationRoutes::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// RequestRouteMissions

// required uint32 seqno = 1;
inline bool RequestRouteMissions::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRouteMissions::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRouteMissions::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRouteMissions::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestRouteMissions::seqno() const {
  return seqno_;
}
inline void RequestRouteMissions::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string uavid = 2;
inline bool RequestRouteMissions::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRouteMissions::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRouteMissions::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRouteMissions::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& RequestRouteMissions::uavid() const {
  return *uavid_;
}
inline void RequestRouteMissions::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void RequestRouteMissions::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void RequestRouteMissions::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestRouteMissions::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* RequestRouteMissions::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestRouteMissions::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool boundary = 3;
inline bool RequestRouteMissions::has_boundary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRouteMissions::set_has_boundary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRouteMissions::clear_has_boundary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRouteMissions::clear_boundary() {
  boundary_ = false;
  clear_has_boundary();
}
inline bool RequestRouteMissions::boundary() const {
  return boundary_;
}
inline void RequestRouteMissions::set_boundary(bool value) {
  set_has_boundary();
  boundary_ = value;
}

// required int32 offset = 4;
inline bool RequestRouteMissions::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRouteMissions::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRouteMissions::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRouteMissions::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 RequestRouteMissions::offset() const {
  return offset_;
}
inline void RequestRouteMissions::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// required int32 count = 5;
inline bool RequestRouteMissions::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestRouteMissions::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestRouteMissions::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestRouteMissions::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 RequestRouteMissions::count() const {
  return count_;
}
inline void RequestRouteMissions::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required uint64 timestamp = 6;
inline bool RequestRouteMissions::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestRouteMissions::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestRouteMissions::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestRouteMissions::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 RequestRouteMissions::timestamp() const {
  return timestamp_;
}
inline void RequestRouteMissions::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// AckRequestRouteMissions

// required uint32 seqno = 1;
inline bool AckRequestRouteMissions::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRequestRouteMissions::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRequestRouteMissions::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRequestRouteMissions::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckRequestRouteMissions::seqno() const {
  return seqno_;
}
inline void AckRequestRouteMissions::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckRequestRouteMissions::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRequestRouteMissions::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRequestRouteMissions::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRequestRouteMissions::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckRequestRouteMissions::result() const {
  return result_;
}
inline void AckRequestRouteMissions::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required bool boundary = 3;
inline bool AckRequestRouteMissions::has_boundary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckRequestRouteMissions::set_has_boundary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckRequestRouteMissions::clear_has_boundary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckRequestRouteMissions::clear_boundary() {
  boundary_ = false;
  clear_has_boundary();
}
inline bool AckRequestRouteMissions::boundary() const {
  return boundary_;
}
inline void AckRequestRouteMissions::set_boundary(bool value) {
  set_has_boundary();
  boundary_ = value;
}

// required int32 offset = 4;
inline bool AckRequestRouteMissions::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckRequestRouteMissions::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckRequestRouteMissions::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckRequestRouteMissions::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 AckRequestRouteMissions::offset() const {
  return offset_;
}
inline void AckRequestRouteMissions::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// repeated bytes missions = 5;
inline int AckRequestRouteMissions::missions_size() const {
  return missions_.size();
}
inline void AckRequestRouteMissions::clear_missions() {
  missions_.Clear();
}
inline const ::std::string& AckRequestRouteMissions::missions(int index) const {
  return missions_.Get(index);
}
inline ::std::string* AckRequestRouteMissions::mutable_missions(int index) {
  return missions_.Mutable(index);
}
inline void AckRequestRouteMissions::set_missions(int index, const ::std::string& value) {
  missions_.Mutable(index)->assign(value);
}
inline void AckRequestRouteMissions::set_missions(int index, const char* value) {
  missions_.Mutable(index)->assign(value);
}
inline void AckRequestRouteMissions::set_missions(int index, const void* value, size_t size) {
  missions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckRequestRouteMissions::add_missions() {
  return missions_.Add();
}
inline void AckRequestRouteMissions::add_missions(const ::std::string& value) {
  missions_.Add()->assign(value);
}
inline void AckRequestRouteMissions::add_missions(const char* value) {
  missions_.Add()->assign(value);
}
inline void AckRequestRouteMissions::add_missions(const void* value, size_t size) {
  missions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AckRequestRouteMissions::missions() const {
  return missions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AckRequestRouteMissions::mutable_missions() {
  return &missions_;
}

// -------------------------------------------------------------------

// UavStatus

// required string uavid = 1;
inline bool UavStatus::has_uavid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UavStatus::set_has_uavid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UavStatus::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UavStatus::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& UavStatus::uavid() const {
  return *uavid_;
}
inline void UavStatus::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void UavStatus::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void UavStatus::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UavStatus::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* UavStatus::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UavStatus::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 result = 2;
inline bool UavStatus::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UavStatus::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UavStatus::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UavStatus::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UavStatus::result() const {
  return result_;
}
inline void UavStatus::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional bool online = 3;
inline bool UavStatus::has_online() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UavStatus::set_has_online() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UavStatus::clear_has_online() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UavStatus::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool UavStatus::online() const {
  return online_;
}
inline void UavStatus::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional bool landed = 4;
inline bool UavStatus::has_landed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UavStatus::set_has_landed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UavStatus::clear_has_landed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UavStatus::clear_landed() {
  landed_ = false;
  clear_has_landed();
}
inline bool UavStatus::landed() const {
  return landed_;
}
inline void UavStatus::set_landed(bool value) {
  set_has_landed();
  landed_ = value;
}

// optional uint64 deadline = 5;
inline bool UavStatus::has_deadline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UavStatus::set_has_deadline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UavStatus::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UavStatus::clear_deadline() {
  deadline_ = GOOGLE_ULONGLONG(0);
  clear_has_deadline();
}
inline ::google::protobuf::uint64 UavStatus::deadline() const {
  return deadline_;
}
inline void UavStatus::set_deadline(::google::protobuf::uint64 value) {
  set_has_deadline();
  deadline_ = value;
}

// optional bool binded = 6;
inline bool UavStatus::has_binded() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UavStatus::set_has_binded() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UavStatus::clear_has_binded() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UavStatus::clear_binded() {
  binded_ = false;
  clear_has_binded();
}
inline bool UavStatus::binded() const {
  return binded_;
}
inline void UavStatus::set_binded(bool value) {
  set_has_binded();
  binded_ = value;
}

// optional string binder = 7;
inline bool UavStatus::has_binder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UavStatus::set_has_binder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UavStatus::clear_has_binder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UavStatus::clear_binder() {
  if (binder_ != &::google::protobuf::internal::kEmptyString) {
    binder_->clear();
  }
  clear_has_binder();
}
inline const ::std::string& UavStatus::binder() const {
  return *binder_;
}
inline void UavStatus::set_binder(const ::std::string& value) {
  set_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    binder_ = new ::std::string;
  }
  binder_->assign(value);
}
inline void UavStatus::set_binder(const char* value) {
  set_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    binder_ = new ::std::string;
  }
  binder_->assign(value);
}
inline void UavStatus::set_binder(const char* value, size_t size) {
  set_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    binder_ = new ::std::string;
  }
  binder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UavStatus::mutable_binder() {
  set_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    binder_ = new ::std::string;
  }
  return binder_;
}
inline ::std::string* UavStatus::release_binder() {
  clear_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = binder_;
    binder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UavStatus::set_allocated_binder(::std::string* binder) {
  if (binder_ != &::google::protobuf::internal::kEmptyString) {
    delete binder_;
  }
  if (binder) {
    set_has_binder();
    binder_ = binder;
  } else {
    clear_has_binder();
    binder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 bindtime = 8;
inline bool UavStatus::has_bindtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UavStatus::set_has_bindtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UavStatus::clear_has_bindtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UavStatus::clear_bindtime() {
  bindtime_ = GOOGLE_ULONGLONG(0);
  clear_has_bindtime();
}
inline ::google::protobuf::uint64 UavStatus::bindtime() const {
  return bindtime_;
}
inline void UavStatus::set_bindtime(::google::protobuf::uint64 value) {
  set_has_bindtime();
  bindtime_ = value;
}

// optional uint64 unbindtime = 9;
inline bool UavStatus::has_unbindtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UavStatus::set_has_unbindtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UavStatus::clear_has_unbindtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UavStatus::clear_unbindtime() {
  unbindtime_ = GOOGLE_ULONGLONG(0);
  clear_has_unbindtime();
}
inline ::google::protobuf::uint64 UavStatus::unbindtime() const {
  return unbindtime_;
}
inline void UavStatus::set_unbindtime(::google::protobuf::uint64 value) {
  set_has_unbindtime();
  unbindtime_ = value;
}

// optional .das.proto.GpsInformation pos = 10;
inline bool UavStatus::has_pos() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UavStatus::set_has_pos() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UavStatus::clear_has_pos() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UavStatus::clear_pos() {
  if (pos_ != NULL) pos_->::das::proto::GpsInformation::Clear();
  clear_has_pos();
}
inline const ::das::proto::GpsInformation& UavStatus::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::das::proto::GpsInformation* UavStatus::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::das::proto::GpsInformation;
  return pos_;
}
inline ::das::proto::GpsInformation* UavStatus::release_pos() {
  clear_has_pos();
  ::das::proto::GpsInformation* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void UavStatus::set_allocated_pos(::das::proto::GpsInformation* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// optional uint64 timestamp = 11;
inline bool UavStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UavStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UavStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UavStatus::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 UavStatus::timestamp() const {
  return timestamp_;
}
inline void UavStatus::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// RequestUavStatus

// required uint32 seqno = 1;
inline bool RequestUavStatus::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUavStatus::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUavStatus::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUavStatus::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestUavStatus::seqno() const {
  return seqno_;
}
inline void RequestUavStatus::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// repeated string uavid = 2;
inline int RequestUavStatus::uavid_size() const {
  return uavid_.size();
}
inline void RequestUavStatus::clear_uavid() {
  uavid_.Clear();
}
inline const ::std::string& RequestUavStatus::uavid(int index) const {
  return uavid_.Get(index);
}
inline ::std::string* RequestUavStatus::mutable_uavid(int index) {
  return uavid_.Mutable(index);
}
inline void RequestUavStatus::set_uavid(int index, const ::std::string& value) {
  uavid_.Mutable(index)->assign(value);
}
inline void RequestUavStatus::set_uavid(int index, const char* value) {
  uavid_.Mutable(index)->assign(value);
}
inline void RequestUavStatus::set_uavid(int index, const char* value, size_t size) {
  uavid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUavStatus::add_uavid() {
  return uavid_.Add();
}
inline void RequestUavStatus::add_uavid(const ::std::string& value) {
  uavid_.Add()->assign(value);
}
inline void RequestUavStatus::add_uavid(const char* value) {
  uavid_.Add()->assign(value);
}
inline void RequestUavStatus::add_uavid(const char* value, size_t size) {
  uavid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RequestUavStatus::uavid() const {
  return uavid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RequestUavStatus::mutable_uavid() {
  return &uavid_;
}

// -------------------------------------------------------------------

// AckRequestUavStatus

// required uint32 seqno = 1;
inline bool AckRequestUavStatus::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRequestUavStatus::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRequestUavStatus::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRequestUavStatus::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckRequestUavStatus::seqno() const {
  return seqno_;
}
inline void AckRequestUavStatus::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// repeated .das.proto.UavStatus status = 2;
inline int AckRequestUavStatus::status_size() const {
  return status_.size();
}
inline void AckRequestUavStatus::clear_status() {
  status_.Clear();
}
inline const ::das::proto::UavStatus& AckRequestUavStatus::status(int index) const {
  return status_.Get(index);
}
inline ::das::proto::UavStatus* AckRequestUavStatus::mutable_status(int index) {
  return status_.Mutable(index);
}
inline ::das::proto::UavStatus* AckRequestUavStatus::add_status() {
  return status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::UavStatus >&
AckRequestUavStatus::status() const {
  return status_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::UavStatus >*
AckRequestUavStatus::mutable_status() {
  return &status_;
}

// -------------------------------------------------------------------

// RequestBindUav

// required uint32 seqno = 1;
inline bool RequestBindUav::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBindUav::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBindUav::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBindUav::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestBindUav::seqno() const {
  return seqno_;
}
inline void RequestBindUav::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required uint32 opid = 2;
inline bool RequestBindUav::has_opid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBindUav::set_has_opid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBindUav::clear_has_opid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBindUav::clear_opid() {
  opid_ = 0u;
  clear_has_opid();
}
inline ::google::protobuf::uint32 RequestBindUav::opid() const {
  return opid_;
}
inline void RequestBindUav::set_opid(::google::protobuf::uint32 value) {
  set_has_opid();
  opid_ = value;
}

// required string uavid = 3;
inline bool RequestBindUav::has_uavid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestBindUav::set_has_uavid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestBindUav::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestBindUav::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& RequestBindUav::uavid() const {
  return *uavid_;
}
inline void RequestBindUav::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void RequestBindUav::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void RequestBindUav::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindUav::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* RequestBindUav::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestBindUav::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string binder = 4;
inline bool RequestBindUav::has_binder() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestBindUav::set_has_binder() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestBindUav::clear_has_binder() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestBindUav::clear_binder() {
  if (binder_ != &::google::protobuf::internal::kEmptyString) {
    binder_->clear();
  }
  clear_has_binder();
}
inline const ::std::string& RequestBindUav::binder() const {
  return *binder_;
}
inline void RequestBindUav::set_binder(const ::std::string& value) {
  set_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    binder_ = new ::std::string;
  }
  binder_->assign(value);
}
inline void RequestBindUav::set_binder(const char* value) {
  set_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    binder_ = new ::std::string;
  }
  binder_->assign(value);
}
inline void RequestBindUav::set_binder(const char* value, size_t size) {
  set_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    binder_ = new ::std::string;
  }
  binder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindUav::mutable_binder() {
  set_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    binder_ = new ::std::string;
  }
  return binder_;
}
inline ::std::string* RequestBindUav::release_binder() {
  clear_has_binder();
  if (binder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = binder_;
    binder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestBindUav::set_allocated_binder(::std::string* binder) {
  if (binder_ != &::google::protobuf::internal::kEmptyString) {
    delete binder_;
  }
  if (binder) {
    set_has_binder();
    binder_ = binder;
  } else {
    clear_has_binder();
    binder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckRequestBindUav

// required uint32 seqno = 1;
inline bool AckRequestBindUav::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRequestBindUav::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRequestBindUav::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRequestBindUav::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckRequestBindUav::seqno() const {
  return seqno_;
}
inline void AckRequestBindUav::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required uint32 opid = 2;
inline bool AckRequestBindUav::has_opid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRequestBindUav::set_has_opid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRequestBindUav::clear_has_opid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRequestBindUav::clear_opid() {
  opid_ = 0u;
  clear_has_opid();
}
inline ::google::protobuf::uint32 AckRequestBindUav::opid() const {
  return opid_;
}
inline void AckRequestBindUav::set_opid(::google::protobuf::uint32 value) {
  set_has_opid();
  opid_ = value;
}

// required int32 result = 3;
inline bool AckRequestBindUav::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckRequestBindUav::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckRequestBindUav::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckRequestBindUav::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckRequestBindUav::result() const {
  return result_;
}
inline void AckRequestBindUav::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .das.proto.UavStatus status = 4;
inline bool AckRequestBindUav::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckRequestBindUav::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckRequestBindUav::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckRequestBindUav::clear_status() {
  if (status_ != NULL) status_->::das::proto::UavStatus::Clear();
  clear_has_status();
}
inline const ::das::proto::UavStatus& AckRequestBindUav::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::das::proto::UavStatus* AckRequestBindUav::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::das::proto::UavStatus;
  return status_;
}
inline ::das::proto::UavStatus* AckRequestBindUav::release_status() {
  clear_has_status();
  ::das::proto::UavStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void AckRequestBindUav::set_allocated_status(::das::proto::UavStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// -------------------------------------------------------------------

// UavProductInfo

// optional string uavid = 1;
inline bool UavProductInfo::has_uavid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UavProductInfo::set_has_uavid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UavProductInfo::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UavProductInfo::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& UavProductInfo::uavid() const {
  return *uavid_;
}
inline void UavProductInfo::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void UavProductInfo::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void UavProductInfo::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UavProductInfo::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* UavProductInfo::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UavProductInfo::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string producttype = 2;
inline bool UavProductInfo::has_producttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UavProductInfo::set_has_producttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UavProductInfo::clear_has_producttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UavProductInfo::clear_producttype() {
  if (producttype_ != &::google::protobuf::internal::kEmptyString) {
    producttype_->clear();
  }
  clear_has_producttype();
}
inline const ::std::string& UavProductInfo::producttype() const {
  return *producttype_;
}
inline void UavProductInfo::set_producttype(const ::std::string& value) {
  set_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    producttype_ = new ::std::string;
  }
  producttype_->assign(value);
}
inline void UavProductInfo::set_producttype(const char* value) {
  set_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    producttype_ = new ::std::string;
  }
  producttype_->assign(value);
}
inline void UavProductInfo::set_producttype(const char* value, size_t size) {
  set_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    producttype_ = new ::std::string;
  }
  producttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UavProductInfo::mutable_producttype() {
  set_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    producttype_ = new ::std::string;
  }
  return producttype_;
}
inline ::std::string* UavProductInfo::release_producttype() {
  clear_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = producttype_;
    producttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UavProductInfo::set_allocated_producttype(::std::string* producttype) {
  if (producttype_ != &::google::protobuf::internal::kEmptyString) {
    delete producttype_;
  }
  if (producttype) {
    set_has_producttype();
    producttype_ = producttype;
  } else {
    clear_has_producttype();
    producttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string productid = 3;
inline bool UavProductInfo::has_productid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UavProductInfo::set_has_productid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UavProductInfo::clear_has_productid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UavProductInfo::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& UavProductInfo::productid() const {
  return *productid_;
}
inline void UavProductInfo::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void UavProductInfo::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void UavProductInfo::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UavProductInfo::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* UavProductInfo::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UavProductInfo::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string organization = 4;
inline bool UavProductInfo::has_organization() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UavProductInfo::set_has_organization() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UavProductInfo::clear_has_organization() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UavProductInfo::clear_organization() {
  if (organization_ != &::google::protobuf::internal::kEmptyString) {
    organization_->clear();
  }
  clear_has_organization();
}
inline const ::std::string& UavProductInfo::organization() const {
  return *organization_;
}
inline void UavProductInfo::set_organization(const ::std::string& value) {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    organization_ = new ::std::string;
  }
  organization_->assign(value);
}
inline void UavProductInfo::set_organization(const char* value) {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    organization_ = new ::std::string;
  }
  organization_->assign(value);
}
inline void UavProductInfo::set_organization(const char* value, size_t size) {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    organization_ = new ::std::string;
  }
  organization_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UavProductInfo::mutable_organization() {
  set_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    organization_ = new ::std::string;
  }
  return organization_;
}
inline ::std::string* UavProductInfo::release_organization() {
  clear_has_organization();
  if (organization_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = organization_;
    organization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UavProductInfo::set_allocated_organization(::std::string* organization) {
  if (organization_ != &::google::protobuf::internal::kEmptyString) {
    delete organization_;
  }
  if (organization) {
    set_has_organization();
    organization_ = organization;
  } else {
    clear_has_organization();
    organization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string manager = 5;
inline bool UavProductInfo::has_manager() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UavProductInfo::set_has_manager() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UavProductInfo::clear_has_manager() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UavProductInfo::clear_manager() {
  if (manager_ != &::google::protobuf::internal::kEmptyString) {
    manager_->clear();
  }
  clear_has_manager();
}
inline const ::std::string& UavProductInfo::manager() const {
  return *manager_;
}
inline void UavProductInfo::set_manager(const ::std::string& value) {
  set_has_manager();
  if (manager_ == &::google::protobuf::internal::kEmptyString) {
    manager_ = new ::std::string;
  }
  manager_->assign(value);
}
inline void UavProductInfo::set_manager(const char* value) {
  set_has_manager();
  if (manager_ == &::google::protobuf::internal::kEmptyString) {
    manager_ = new ::std::string;
  }
  manager_->assign(value);
}
inline void UavProductInfo::set_manager(const char* value, size_t size) {
  set_has_manager();
  if (manager_ == &::google::protobuf::internal::kEmptyString) {
    manager_ = new ::std::string;
  }
  manager_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UavProductInfo::mutable_manager() {
  set_has_manager();
  if (manager_ == &::google::protobuf::internal::kEmptyString) {
    manager_ = new ::std::string;
  }
  return manager_;
}
inline ::std::string* UavProductInfo::release_manager() {
  clear_has_manager();
  if (manager_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manager_;
    manager_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UavProductInfo::set_allocated_manager(::std::string* manager) {
  if (manager_ != &::google::protobuf::internal::kEmptyString) {
    delete manager_;
  }
  if (manager) {
    set_has_manager();
    manager_ = manager;
  } else {
    clear_has_manager();
    manager_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string contact = 6;
inline bool UavProductInfo::has_contact() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UavProductInfo::set_has_contact() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UavProductInfo::clear_has_contact() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UavProductInfo::clear_contact() {
  if (contact_ != &::google::protobuf::internal::kEmptyString) {
    contact_->clear();
  }
  clear_has_contact();
}
inline const ::std::string& UavProductInfo::contact() const {
  return *contact_;
}
inline void UavProductInfo::set_contact(const ::std::string& value) {
  set_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    contact_ = new ::std::string;
  }
  contact_->assign(value);
}
inline void UavProductInfo::set_contact(const char* value) {
  set_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    contact_ = new ::std::string;
  }
  contact_->assign(value);
}
inline void UavProductInfo::set_contact(const char* value, size_t size) {
  set_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    contact_ = new ::std::string;
  }
  contact_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UavProductInfo::mutable_contact() {
  set_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    contact_ = new ::std::string;
  }
  return contact_;
}
inline ::std::string* UavProductInfo::release_contact() {
  clear_has_contact();
  if (contact_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contact_;
    contact_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UavProductInfo::set_allocated_contact(::std::string* contact) {
  if (contact_ != &::google::protobuf::internal::kEmptyString) {
    delete contact_;
  }
  if (contact) {
    set_has_contact();
    contact_ = contact;
  } else {
    clear_has_contact();
    contact_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestUavProductInfos

// required uint32 seqno = 1;
inline bool RequestUavProductInfos::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUavProductInfos::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUavProductInfos::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUavProductInfos::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 RequestUavProductInfos::seqno() const {
  return seqno_;
}
inline void RequestUavProductInfos::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// repeated string productid = 2;
inline int RequestUavProductInfos::productid_size() const {
  return productid_.size();
}
inline void RequestUavProductInfos::clear_productid() {
  productid_.Clear();
}
inline const ::std::string& RequestUavProductInfos::productid(int index) const {
  return productid_.Get(index);
}
inline ::std::string* RequestUavProductInfos::mutable_productid(int index) {
  return productid_.Mutable(index);
}
inline void RequestUavProductInfos::set_productid(int index, const ::std::string& value) {
  productid_.Mutable(index)->assign(value);
}
inline void RequestUavProductInfos::set_productid(int index, const char* value) {
  productid_.Mutable(index)->assign(value);
}
inline void RequestUavProductInfos::set_productid(int index, const char* value, size_t size) {
  productid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUavProductInfos::add_productid() {
  return productid_.Add();
}
inline void RequestUavProductInfos::add_productid(const ::std::string& value) {
  productid_.Add()->assign(value);
}
inline void RequestUavProductInfos::add_productid(const char* value) {
  productid_.Add()->assign(value);
}
inline void RequestUavProductInfos::add_productid(const char* value, size_t size) {
  productid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RequestUavProductInfos::productid() const {
  return productid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RequestUavProductInfos::mutable_productid() {
  return &productid_;
}

// repeated string uavid = 3;
inline int RequestUavProductInfos::uavid_size() const {
  return uavid_.size();
}
inline void RequestUavProductInfos::clear_uavid() {
  uavid_.Clear();
}
inline const ::std::string& RequestUavProductInfos::uavid(int index) const {
  return uavid_.Get(index);
}
inline ::std::string* RequestUavProductInfos::mutable_uavid(int index) {
  return uavid_.Mutable(index);
}
inline void RequestUavProductInfos::set_uavid(int index, const ::std::string& value) {
  uavid_.Mutable(index)->assign(value);
}
inline void RequestUavProductInfos::set_uavid(int index, const char* value) {
  uavid_.Mutable(index)->assign(value);
}
inline void RequestUavProductInfos::set_uavid(int index, const char* value, size_t size) {
  uavid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUavProductInfos::add_uavid() {
  return uavid_.Add();
}
inline void RequestUavProductInfos::add_uavid(const ::std::string& value) {
  uavid_.Add()->assign(value);
}
inline void RequestUavProductInfos::add_uavid(const char* value) {
  uavid_.Add()->assign(value);
}
inline void RequestUavProductInfos::add_uavid(const char* value, size_t size) {
  uavid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RequestUavProductInfos::uavid() const {
  return uavid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RequestUavProductInfos::mutable_uavid() {
  return &uavid_;
}

// -------------------------------------------------------------------

// AckRequestUavProductInfos

// required uint32 seqno = 1;
inline bool AckRequestUavProductInfos::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRequestUavProductInfos::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRequestUavProductInfos::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRequestUavProductInfos::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckRequestUavProductInfos::seqno() const {
  return seqno_;
}
inline void AckRequestUavProductInfos::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckRequestUavProductInfos::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRequestUavProductInfos::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRequestUavProductInfos::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRequestUavProductInfos::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckRequestUavProductInfos::result() const {
  return result_;
}
inline void AckRequestUavProductInfos::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated .das.proto.UavProductInfo upi = 3;
inline int AckRequestUavProductInfos::upi_size() const {
  return upi_.size();
}
inline void AckRequestUavProductInfos::clear_upi() {
  upi_.Clear();
}
inline const ::das::proto::UavProductInfo& AckRequestUavProductInfos::upi(int index) const {
  return upi_.Get(index);
}
inline ::das::proto::UavProductInfo* AckRequestUavProductInfos::mutable_upi(int index) {
  return upi_.Mutable(index);
}
inline ::das::proto::UavProductInfo* AckRequestUavProductInfos::add_upi() {
  return upi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo >&
AckRequestUavProductInfos::upi() const {
  return upi_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo >*
AckRequestUavProductInfos::mutable_upi() {
  return &upi_;
}

// -------------------------------------------------------------------

// PostUavProductInfos

// required uint32 seqno = 1;
inline bool PostUavProductInfos::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostUavProductInfos::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostUavProductInfos::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostUavProductInfos::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostUavProductInfos::seqno() const {
  return seqno_;
}
inline void PostUavProductInfos::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// repeated .das.proto.UavProductInfo upi = 2;
inline int PostUavProductInfos::upi_size() const {
  return upi_.size();
}
inline void PostUavProductInfos::clear_upi() {
  upi_.Clear();
}
inline const ::das::proto::UavProductInfo& PostUavProductInfos::upi(int index) const {
  return upi_.Get(index);
}
inline ::das::proto::UavProductInfo* PostUavProductInfos::mutable_upi(int index) {
  return upi_.Mutable(index);
}
inline ::das::proto::UavProductInfo* PostUavProductInfos::add_upi() {
  return upi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo >&
PostUavProductInfos::upi() const {
  return upi_;
}
inline ::google::protobuf::RepeatedPtrField< ::das::proto::UavProductInfo >*
PostUavProductInfos::mutable_upi() {
  return &upi_;
}

// -------------------------------------------------------------------

// AckPostUavProductInfos

// required uint32 seqno = 1;
inline bool AckPostUavProductInfos::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostUavProductInfos::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostUavProductInfos::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostUavProductInfos::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostUavProductInfos::seqno() const {
  return seqno_;
}
inline void AckPostUavProductInfos::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPostUavProductInfos::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostUavProductInfos::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostUavProductInfos::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostUavProductInfos::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPostUavProductInfos::result() const {
  return result_;
}
inline void AckPostUavProductInfos::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// PostControl2Uav

// required uint32 seqno = 1;
inline bool PostControl2Uav::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostControl2Uav::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostControl2Uav::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostControl2Uav::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostControl2Uav::seqno() const {
  return seqno_;
}
inline void PostControl2Uav::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string uavid = 2;
inline bool PostControl2Uav::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostControl2Uav::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostControl2Uav::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostControl2Uav::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& PostControl2Uav::uavid() const {
  return *uavid_;
}
inline void PostControl2Uav::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void PostControl2Uav::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void PostControl2Uav::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostControl2Uav::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* PostControl2Uav::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostControl2Uav::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userid = 3;
inline bool PostControl2Uav::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostControl2Uav::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostControl2Uav::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostControl2Uav::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& PostControl2Uav::userid() const {
  return *userid_;
}
inline void PostControl2Uav::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void PostControl2Uav::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void PostControl2Uav::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostControl2Uav::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* PostControl2Uav::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostControl2Uav::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes data = 4;
inline int PostControl2Uav::data_size() const {
  return data_.size();
}
inline void PostControl2Uav::clear_data() {
  data_.Clear();
}
inline const ::std::string& PostControl2Uav::data(int index) const {
  return data_.Get(index);
}
inline ::std::string* PostControl2Uav::mutable_data(int index) {
  return data_.Mutable(index);
}
inline void PostControl2Uav::set_data(int index, const ::std::string& value) {
  data_.Mutable(index)->assign(value);
}
inline void PostControl2Uav::set_data(int index, const char* value) {
  data_.Mutable(index)->assign(value);
}
inline void PostControl2Uav::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostControl2Uav::add_data() {
  return data_.Add();
}
inline void PostControl2Uav::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
}
inline void PostControl2Uav::add_data(const char* value) {
  data_.Add()->assign(value);
}
inline void PostControl2Uav::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PostControl2Uav::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PostControl2Uav::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// AckPostControl2Uav

// required uint32 seqno = 1;
inline bool AckPostControl2Uav::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPostControl2Uav::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPostControl2Uav::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPostControl2Uav::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 AckPostControl2Uav::seqno() const {
  return seqno_;
}
inline void AckPostControl2Uav::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required int32 result = 2;
inline bool AckPostControl2Uav::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPostControl2Uav::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPostControl2Uav::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPostControl2Uav::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPostControl2Uav::result() const {
  return result_;
}
inline void AckPostControl2Uav::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string uavid = 3;
inline bool AckPostControl2Uav::has_uavid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckPostControl2Uav::set_has_uavid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckPostControl2Uav::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckPostControl2Uav::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& AckPostControl2Uav::uavid() const {
  return *uavid_;
}
inline void AckPostControl2Uav::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void AckPostControl2Uav::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void AckPostControl2Uav::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPostControl2Uav::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* AckPostControl2Uav::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPostControl2Uav::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userid = 4;
inline bool AckPostControl2Uav::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckPostControl2Uav::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckPostControl2Uav::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckPostControl2Uav::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& AckPostControl2Uav::userid() const {
  return *userid_;
}
inline void AckPostControl2Uav::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AckPostControl2Uav::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AckPostControl2Uav::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckPostControl2Uav::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* AckPostControl2Uav::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckPostControl2Uav::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostStatus2GroundStation

// required uint32 seqno = 1;
inline bool PostStatus2GroundStation::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostStatus2GroundStation::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostStatus2GroundStation::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostStatus2GroundStation::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 PostStatus2GroundStation::seqno() const {
  return seqno_;
}
inline void PostStatus2GroundStation::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
}

// required string uavid = 2;
inline bool PostStatus2GroundStation::has_uavid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostStatus2GroundStation::set_has_uavid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostStatus2GroundStation::clear_has_uavid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostStatus2GroundStation::clear_uavid() {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    uavid_->clear();
  }
  clear_has_uavid();
}
inline const ::std::string& PostStatus2GroundStation::uavid() const {
  return *uavid_;
}
inline void PostStatus2GroundStation::set_uavid(const ::std::string& value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void PostStatus2GroundStation::set_uavid(const char* value) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(value);
}
inline void PostStatus2GroundStation::set_uavid(const char* value, size_t size) {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  uavid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostStatus2GroundStation::mutable_uavid() {
  set_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    uavid_ = new ::std::string;
  }
  return uavid_;
}
inline ::std::string* PostStatus2GroundStation::release_uavid() {
  clear_has_uavid();
  if (uavid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uavid_;
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostStatus2GroundStation::set_allocated_uavid(::std::string* uavid) {
  if (uavid_ != &::google::protobuf::internal::kEmptyString) {
    delete uavid_;
  }
  if (uavid) {
    set_has_uavid();
    uavid_ = uavid;
  } else {
    clear_has_uavid();
    uavid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes data = 3;
inline int PostStatus2GroundStation::data_size() const {
  return data_.size();
}
inline void PostStatus2GroundStation::clear_data() {
  data_.Clear();
}
inline const ::std::string& PostStatus2GroundStation::data(int index) const {
  return data_.Get(index);
}
inline ::std::string* PostStatus2GroundStation::mutable_data(int index) {
  return data_.Mutable(index);
}
inline void PostStatus2GroundStation::set_data(int index, const ::std::string& value) {
  data_.Mutable(index)->assign(value);
}
inline void PostStatus2GroundStation::set_data(int index, const char* value) {
  data_.Mutable(index)->assign(value);
}
inline void PostStatus2GroundStation::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostStatus2GroundStation::add_data() {
  return data_.Add();
}
inline void PostStatus2GroundStation::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
}
inline void PostStatus2GroundStation::add_data(const char* value) {
  data_.Add()->assign(value);
}
inline void PostStatus2GroundStation::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PostStatus2GroundStation::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PostStatus2GroundStation::mutable_data() {
  return &data_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace das

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::das::proto::SurveryPrecision>() {
  return ::das::proto::SurveryPrecision_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_das_2eproto__INCLUDED
